import os
import shutil
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional, Any
from .models import ReportContext, Finding, FindingType, Severity

class MarkdownGenerator:
    """
    Generates professional Markdown reports (Technical & Executive) 
    within a structured directory including visual evidence.
    """
    def __init__(self, output_base_dir: str = "reports"):
        self.output_base_dir = Path(output_base_dir)
        self.output_base_dir.mkdir(parents=True, exist_ok=True)

    def generate(self, context: ReportContext) -> str:
        """
        Creates a folder for the current scan and generates reports.
        Returns the path to the report directory.
        """
        timestamp = context.scan_date.strftime("%Y%m%d_%H%M%S")
        target_slug = context.target_url.replace("://", "_").replace("/", "_").replace(".", "_")
        report_dir = self.output_base_dir / f"report_{target_slug}_{timestamp}"
        report_dir.mkdir(parents=True, exist_ok=True)
        
        captures_dir = report_dir / "captures"
        captures_dir.mkdir(parents=True, exist_ok=True)

        # 1. Generate Technical Report (Markdown)
        tech_path = report_dir / "technical_report.md"
        self._write_technical_report(context, tech_path, report_dir)

        # 2. Generate Executive Summary (Markdown)
        exec_path = report_dir / "executive_summary.md"
        self._write_executive_summary(context, exec_path)

        # 3. Save Comprehensive Engagement Data (JSON)
        json_path = report_dir / "engagement_data.json"
        self._save_engagement_json(context, json_path)

        return str(report_dir)

    def _save_engagement_json(self, context: ReportContext, path: Path):
        """Saves the full scan context as a structured JSON file."""
        import json
        with open(path, "w", encoding="utf-8") as f:
            # We use context.model_dump_json() if it's a Pydantic model
            f.write(context.model_dump_json(indent=4))

    def _write_technical_report(self, context: ReportContext, path: Path, report_dir: Path):
        with open(path, "w", encoding="utf-8") as f:
            f.write(f"# Technical Assessment: {context.target_url}\n\n")
            f.write(f"**Generated by**: BugtraceAI (Burp Suite Pro Emulation)\n")
            f.write(f"**Date**: {context.scan_date.strftime('%d %b %Y')}\n\n")

            f.write(f"## 1. Engagement Summary\n")
            f.write(f"This document reports on the security assessment of **{context.target_url}**. ")
            f.write(f"The following issues were identified and classified according to industry standards.\n\n")

            f.write(f"## 2. Detailed Findings\n\n")
            
            vulnerabilities = [f for f in context.findings if f.type == FindingType.VULNERABILITY]
            
            # Sort by Severity (Critical -> Info)
            severity_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3, "Information": 4}
            vulnerabilities.sort(key=lambda x: severity_order.get(x.severity.value, 5))

            if not vulnerabilities:
                f.write("No significant vulnerabilities were identified.\n")
            else:
                for idx, vuln in enumerate(vulnerabilities, 1):
                    # Title Block
                    f.write(f"### 2.{idx}. {vuln.title}\n\n")
                    
                    # Metadata Table
                    f.write(f"| Classification | Detail |\n")
                    f.write(f"| :--- | :--- |\n")
                    f.write(f"| **Severity** | {vuln.severity.value} |\n")
                    f.write(f"| **Confidence** | {vuln.confidence.value} |\n")
                    ftype = vuln.validation_method or vuln.metadata.get('validation_method', 'Automated Check')
                    f.write(f"| **Validation** | {ftype} |\n")
                    f.write(f"\n")

                    # Warning for Manual Review findings
                    if vuln.metadata.get("status") == "MANUAL_REVIEW_RECOMMENDED":
                        f.write(f"> ‚ö†Ô∏è **ATTENTION TRIAGER**: This finding has high AI confidence but could not be confirmed via browser automation. Manual verification recommended.\n\n")

                    # BUG BOUNTY SECTION: Steps to Reproduce
                    f.write(f"#### üïµÔ∏è Steps to Reproduce (Triager Ready)\n")
                    
                    # Generate dynamic steps if not present
                    param = vuln.metadata.get('parameter', 'target parameter')
                    payload = vuln.metadata.get('payload', '<payload>')
                    if 'reproduction_steps' in vuln.metadata and vuln.metadata['reproduction_steps']:
                        steps = vuln.metadata['reproduction_steps']
                    else:
                        # Fallback heuristic steps
                        if "XSS" in vuln.title:
                            steps = [
                                f"1. Open the target URL: `{vuln.metadata.get('url', context.target_url)}`",
                                f"2. Locate the input parameter `{param}`.",
                                f"3. Inject the following payload: `{payload}`",
                                f"4. Observe the execution of the payload (e.g., alert box, DOM change)."
                            ]
                        elif "SQL" in vuln.title:
                            steps = [
                                f"1. Send a request to `{vuln.metadata.get('url', context.target_url)}`",
                                f"2. Modify the parameter `{param}` with the payload: `{payload}`",
                                f"3. Observe the database error or time delay in the response."
                            ]
                        else:
                            steps = [
                                f"1. Navigate to `{vuln.metadata.get('url', context.target_url)}`",
                                f"2. Observe the issue described below."
                            ]
                    
                    for s in steps:
                        f.write(f"- {s}\n")
                    f.write(f"\n")

                    # BUG BOUNTY SECTION: Proof of Concept Code
                    f.write(f"#### üí• Proof of Concept (Curl)\n")
                    # Heuristic Curl generation
                    target = vuln.metadata.get('url', context.target_url)
                    method = vuln.metadata.get('method', 'GET')
                    poc_payload = payload.replace('"', '\\"') if payload else ""
                    
                    if method == 'POST':
                         poc_cmd = f'curl -X POST "{target}" -d "{param}={poc_payload}"'
                    else:
                        # Assume GET
                        if '?' in target:
                             poc_cmd = f'curl "{target}"' # Payload likely already in URL
                        else:
                             poc_cmd = f'curl "{target}?{param}={poc_payload}"'
                    
                    f.write(f"```bash\n{poc_cmd}\n```\n\n")

                    # Issue Background
                    f.write(f"#### Limitaciones y Contexto (Issue Background)\n")
                    f.write(f"{vuln.description}\n\n")

                    # Issue Detail
                    if vuln.impact:
                         f.write(f"#### Detalle del Hallazgo (Issue Detail)\n")
                         f.write(f"{vuln.impact}\n\n")

                    # Mitigation / Remediation
                    if vuln.remediation:
                        f.write(f"#### Remediaci√≥n (Remediation)\n")
                        f.write(f"{vuln.remediation}\n\n")

                    # References
                    if vuln.references:
                        f.write(f"#### Referencias\n")
                        for ref in vuln.references:
                            f.write(f"- {ref}\n")
                        f.write("\n")

                    # Evidence (Request / Response)
                    if vuln.http_request:
                        f.write(f"#### Petici√≥n de Prueba (Request)\n")
                        f.write(f"```http\n{vuln.http_request}\n```\n")
                    
                    if vuln.http_response:
                        f.write(f"#### Respuesta del Servidor (Response)\n")
                        f.write(f"```http\n{vuln.http_response}\n```\n")

                    # Visual Proofs (From Evidence Objects or Metadata)
                    has_visuals = False
                    if vuln.evidence or vuln.metadata.get("screenshot_path"):
                        f.write(f"#### Evidencia Visual\n")
                        has_visuals = True

                    # 1. Render Evidence Objects
                    if vuln.evidence:
                        for evidence in vuln.evidence:
                            f.write(f"- {evidence.description}\n")
                    
                    # 2. Render Screenshot from Metadata
                    img_path = vuln.metadata.get("screenshot_path")
                    if img_path and os.path.exists(img_path):
                        img_name = os.path.basename(img_path)
                        dest_path = report_dir / "captures" / img_name
                        try:
                            shutil.copy(img_path, dest_path)
                            f.write(f"\n![Visual Proof](captures/{img_name})\n")
                        except Exception as e:
                            pass
                    elif img_path:
                         f.write(f"\n*(Screenshot referenced but file not found: {img_path})*\n")
                    

                    # Validator Notes (Manager Audit)
                    validator_notes = vuln.metadata.get("validator_notes")
                    validation_status = vuln.metadata.get("status", "")

                    if validator_notes or validation_status:
                        f.write(f"#### üõ°Ô∏è Validation Audit (Manager Review)\n")

                        # Status badge
                        if validation_status == "VALIDATED_CONFIRMED":
                            f.write(f"**Status:** ‚úÖ CONFIRMED\n\n")
                        elif validation_status == "MANUAL_REVIEW_RECOMMENDED":
                            f.write(f"**Status:** ‚ö†Ô∏è NEEDS MANUAL REVIEW\n\n")
                        elif validation_status == "VALIDATED_FALSE_POSITIVE":
                            f.write(f"**Status:** ‚ùå FALSE POSITIVE\n\n")

                        # Reasoning from AgenticValidator
                        if validator_notes:
                            f.write(f"**AI Validator Comment:**\n")
                            f.write(f"> {validator_notes}\n\n")

                    f.write("\n---\n\n")

    def _write_executive_summary(self, context: ReportContext, path: Path):
        # Calculate Matrix
        matrix = {
            "High": {"Certain": 0, "Firm": 0, "Tentative": 0},
            "Medium": {"Certain": 0, "Firm": 0, "Tentative": 0},
            "Low": {"Certain": 0, "Firm": 0, "Tentative": 0},
            "Information": {"Certain": 0, "Firm": 0, "Tentative": 0}
        }
        
        for f in context.findings:
            if f.type == FindingType.VULNERABILITY:
                sev = f.severity.value
                conf = f.confidence.value
                if sev in matrix and conf in matrix[sev]:
                    matrix[sev][conf] += 1

        with open(path, "w", encoding="utf-8") as f:
            f.write(f"# Executive Summary: {context.target_url}\n\n")
            f.write(f"**Date**: {context.scan_date.strftime('%d %b %Y')}\n\n")

            f.write(f"## 1. Resumen de Problemas (Summary)\n")
            f.write(f"BugtraceAI ha identificado los siguientes problemas clasificados por severidad y confianza.\n\n")

            f.write(f"### Tabla de Clasificaci√≥n (Severity vs Confidence)\n")
            f.write(f"| Severity | Certain | Firm | Tentative | Total |\n")
            f.write(f"| :--- | :--- | :--- | :--- | :--- |\n")
            
            total_high = sum(matrix["High"].values())
            total_med = sum(matrix["Medium"].values())
            total_low = sum(matrix["Low"].values())
            total_info = sum(matrix["Information"].values())
            
            f.write(f"| **High** | {matrix['High']['Certain']} | {matrix['High']['Firm']} | {matrix['High']['Tentative']} | **{total_high}** |\n")
            f.write(f"| **Medium** | {matrix['Medium']['Certain']} | {matrix['Medium']['Firm']} | {matrix['Medium']['Tentative']} | **{total_med}** |\n")
            f.write(f"| **Low** | {matrix['Low']['Certain']} | {matrix['Low']['Firm']} | {matrix['Low']['Tentative']} | **{total_low}** |\n")
            f.write(f"| **Information** | {matrix['Information']['Certain']} | {matrix['Information']['Firm']} | {matrix['Information']['Tentative']} | **{total_info}** |\n\n")

            f.write(f"## Nota sobre Privacidad (IAB TCF)\n")
            f.write(f"> **Privacy Notice**: El sitio y sus socios pueden almacenar y acceder a informaci√≥n en el dispositivo para publicidad personalizada, medici√≥n de contenido e investigaci√≥n de audiencia. Se procesan datos de geolocalizaci√≥n y caracter√≠sticas del dispositivo.\n\n")
