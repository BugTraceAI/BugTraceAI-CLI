import os
import shutil
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional, Any
from .models import ReportContext, Finding, FindingType, Severity
from bugtrace.utils.logger import get_logger

logger = get_logger("reporting.markdown_generator")

class MarkdownGenerator:
    """
    Generates professional Markdown reports (Technical & Executive) 
    within a structured directory including visual evidence.
    """
    def __init__(self, output_base_dir: str = "reports"):
        self.output_base_dir = Path(output_base_dir)
        self.output_base_dir.mkdir(parents=True, exist_ok=True)

    def generate(self, context: ReportContext) -> str:
        """
        Creates a folder for the current scan and generates reports.
        Returns the path to the report directory.
        """
        timestamp = context.scan_date.strftime("%Y%m%d_%H%M%S")
        target_slug = context.target_url.replace("://", "_").replace("/", "_").replace(".", "_")
        report_dir = self.output_base_dir / f"report_{target_slug}_{timestamp}"
        report_dir.mkdir(parents=True, exist_ok=True)
        
        captures_dir = report_dir / "captures"
        captures_dir.mkdir(parents=True, exist_ok=True)

        # 1. Generate Technical Report (Markdown)
        tech_path = report_dir / "technical_report.md"
        self._write_technical_report(context, tech_path, report_dir)

        # 2. Generate Executive Summary (Markdown)
        exec_path = report_dir / "executive_summary.md"
        self._write_executive_summary(context, exec_path)

        # 3. Save Comprehensive Engagement Data (JSON)
        json_path = report_dir / "engagement_data.json"
        self._save_engagement_json(context, json_path)

        return str(report_dir)

    def _save_engagement_json(self, context: ReportContext, path: Path):
        """Saves the full scan context as a structured JSON file."""
        import json
        with open(path, "w", encoding="utf-8") as f:
            # We use context.model_dump_json() if it's a Pydantic model
            f.write(context.model_dump_json(indent=4))

    def _write_technical_report(self, context: ReportContext, path: Path, report_dir: Path):
        with open(path, "w", encoding="utf-8") as f:
            self._write_report_header(f, context)
            self._write_detailed_findings(f, context, report_dir)

    def _write_report_header(self, f, context: ReportContext):
        """Write report header and engagement summary."""
        f.write(f"# Technical Assessment: {context.target_url}\n\n")
        f.write(f"**Generated by**: BugtraceAI (Burp Suite Pro Emulation)\n")
        f.write(f"**Date**: {context.scan_date.strftime('%d %b %Y')}\n")
        if context.stats and context.stats.duration_seconds:
            total = int(context.stats.duration_seconds)
            hours, remainder = divmod(total, 3600)
            minutes, seconds = divmod(remainder, 60)
            f.write(f"**Duration**: {hours}h {minutes}m {seconds}s\n")
        f.write("\n")

        f.write(f"## 1. Engagement Summary\n")
        f.write(f"This document reports on the security assessment of **{context.target_url}**. ")
        f.write(f"The following issues were identified and classified according to industry standards.\n\n")

    def _write_detailed_findings(self, f, context: ReportContext, report_dir: Path):
        """Write detailed findings section."""
        f.write(f"## 2. Detailed Findings\n\n")

        vulnerabilities = [f for f in context.findings if f.type == FindingType.VULNERABILITY]

        # Sort by Severity (Critical -> Info)
        severity_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3, "Information": 4}
        vulnerabilities.sort(key=lambda x: severity_order.get(x.severity.value, 5))

        if not vulnerabilities:
            f.write("No significant vulnerabilities were identified.\n")
        else:
            for idx, vuln in enumerate(vulnerabilities, 1):
                self._write_vulnerability_entry(f, context, vuln, idx, report_dir)

    def _write_vulnerability_entry(self, f, context: ReportContext, vuln, idx: int, report_dir: Path):
        """Write a single vulnerability entry."""
        # Title Block
        f.write(f"### 2.{idx}. {vuln.title}\n\n")

        # Metadata Table
        self._write_vulnerability_metadata(f, vuln)

        # Warning for Manual Review findings
        if vuln.metadata.get("status") == "MANUAL_REVIEW_RECOMMENDED":
            f.write(f"> ‚ö†Ô∏è **ATTENTION TRIAGER**: This finding has high AI confidence but could not be confirmed via browser automation. Manual verification recommended.\n\n")

        # Bug Bounty Sections
        self._write_reproduction_steps(f, context, vuln)
        self._write_proof_of_concept(f, context, vuln)

        # Technical Details
        self._write_vulnerability_details(f, vuln)

        # Evidence
        self._write_vulnerability_evidence(f, vuln, report_dir)

        # Validation Audit
        self._write_validation_audit(f, vuln)

        f.write("\n---\n\n")

    def _write_vulnerability_metadata(self, f, vuln):
        """Write vulnerability classification metadata table."""
        f.write(f"| Classification | Detail |\n")
        f.write(f"| :--- | :--- |\n")
        f.write(f"| **Severity** | {vuln.severity.value} |\n")
        f.write(f"| **Confidence** | {vuln.confidence.value} |\n")
        ftype = vuln.validation_method or vuln.metadata.get('validation_method', 'Automated Check')
        f.write(f"| **Validation** | {ftype} |\n")
        f.write(f"\n")

    def _write_reproduction_steps(self, f, context: ReportContext, vuln):
        """Write steps to reproduce section."""
        f.write(f"#### üïµÔ∏è Steps to Reproduce (Triager Ready)\n")

        param = vuln.metadata.get('parameter', 'target parameter')
        payload = vuln.metadata.get('payload', '<payload>')

        if 'reproduction_steps' in vuln.metadata and vuln.metadata['reproduction_steps']:
            steps = vuln.metadata['reproduction_steps']
        else:
            steps = self._generate_fallback_steps(vuln, context, param, payload)

        for s in steps:
            f.write(f"- {s}\n")
        f.write(f"\n")

    def _generate_fallback_steps(self, vuln, context: ReportContext, param: str, payload: str) -> list:
        """Generate fallback reproduction steps based on vulnerability type."""
        url = vuln.metadata.get('url', context.target_url)

        if "XSS" in vuln.title:
            return [
                f"1. Open the target URL: `{url}`",
                f"2. Locate the input parameter `{param}`.",
                f"3. Inject the following payload: `{payload}`",
                f"4. Observe the execution of the payload (e.g., alert box, DOM change)."
            ]
        elif "SQL" in vuln.title:
            return [
                f"1. Send a request to `{url}`",
                f"2. Modify the parameter `{param}` with the payload: `{payload}`",
                f"3. Observe the database error or time delay in the response."
            ]
        else:
            return [
                f"1. Navigate to `{url}`",
                f"2. Observe the issue described below."
            ]

    def _write_proof_of_concept(self, f, context: ReportContext, vuln):
        """Write proof of concept curl command."""
        f.write(f"#### üí• Proof of Concept (Curl)\n")

        target = vuln.metadata.get('url', context.target_url)
        method = vuln.metadata.get('method', 'GET')
        param = vuln.metadata.get('parameter', 'target parameter')
        payload = vuln.metadata.get('payload', '<payload>')
        poc_payload = payload.replace('"', '\\"') if payload else ""

        if method == 'POST':
            poc_cmd = f'curl -X POST "{target}" -d "{param}={poc_payload}"'
        else:
            if '?' in target:
                poc_cmd = f'curl "{target}"'
            else:
                poc_cmd = f'curl "{target}?{param}={poc_payload}"'

        f.write(f"```bash\n{poc_cmd}\n```\n\n")

    def _write_vulnerability_details(self, f, vuln):
        """Write vulnerability description, impact, remediation, and references."""
        # Issue Background
        f.write(f"#### Limitaciones y Contexto (Issue Background)\n")
        f.write(f"{vuln.description}\n\n")

        # Issue Detail
        if vuln.impact:
            f.write(f"#### Detalle del Hallazgo (Issue Detail)\n")
            f.write(f"{vuln.impact}\n\n")

        # Mitigation / Remediation
        if vuln.remediation:
            f.write(f"#### Remediaci√≥n (Remediation)\n")
            f.write(f"{vuln.remediation}\n\n")

        # References
        if vuln.references:
            f.write(f"#### Referencias\n")
            for ref in vuln.references:
                f.write(f"- {ref}\n")
            f.write("\n")

    def _write_vulnerability_evidence(self, f, vuln, report_dir: Path):
        """Write HTTP evidence and visual proofs."""
        # Evidence (Request / Response)
        if vuln.http_request:
            f.write(f"#### Petici√≥n de Prueba (Request)\n")
            f.write(f"```http\n{vuln.http_request}\n```\n")

        if vuln.http_response:
            f.write(f"#### Respuesta del Servidor (Response)\n")
            f.write(f"```http\n{vuln.http_response}\n```\n")

        # Visual Proofs
        if vuln.evidence or vuln.metadata.get("screenshot_path"):
            f.write(f"#### Evidencia Visual\n")

        # Render Evidence Objects
        if vuln.evidence:
            for evidence in vuln.evidence:
                f.write(f"- {evidence.description}\n")

        # Render Screenshot from Metadata
        self._copy_and_link_screenshot(f, vuln, report_dir)

    def _copy_and_link_screenshot(self, f, vuln, report_dir: Path):
        """Copy screenshot to report directory and link it."""
        img_path = vuln.metadata.get("screenshot_path")
        if img_path and os.path.exists(img_path):
            img_name = os.path.basename(img_path)
            dest_path = report_dir / "captures" / img_name
            try:
                shutil.copy(img_path, dest_path)
                f.write(f"\n![Visual Proof](captures/{img_name})\n")
            except (OSError, IOError, PermissionError) as e:
                logger.warning(f"Failed to copy screenshot {img_name}: {e}")
        elif img_path:
            f.write(f"\n*(Screenshot referenced but file not found: {img_path})*\n")

    def _write_validation_audit(self, f, vuln):
        """Write validation audit section if validator notes exist."""
        validator_notes = vuln.metadata.get("validator_notes")
        validation_status = vuln.metadata.get("status", "")

        if not (validator_notes or validation_status):
            return

        f.write(f"#### üõ°Ô∏è Validation Audit (Manager Review)\n")
        self._write_validation_status_badge(f, validation_status)
        self._write_validator_notes(f, validator_notes)

    def _write_validation_status_badge(self, f, validation_status: str):
        """Write validation status badge."""
        status_badges = {
            "VALIDATED_CONFIRMED": "**Status:** ‚úÖ CONFIRMED\n\n",
            "MANUAL_REVIEW_RECOMMENDED": "**Status:** ‚ö†Ô∏è NEEDS MANUAL REVIEW\n\n",
            "VALIDATED_FALSE_POSITIVE": "**Status:** ‚ùå FALSE POSITIVE\n\n"
        }

        badge = status_badges.get(validation_status)
        if badge:
            f.write(badge)

    def _write_validator_notes(self, f, validator_notes: str):
        """Write validator notes if present."""
        if validator_notes:
            f.write(f"**AI Validator Comment:**\n")
            f.write(f"> {validator_notes}\n\n")

    def _write_executive_summary(self, context: ReportContext, path: Path):
        # Calculate Matrix
        matrix = {
            "High": {"Certain": 0, "Firm": 0, "Tentative": 0},
            "Medium": {"Certain": 0, "Firm": 0, "Tentative": 0},
            "Low": {"Certain": 0, "Firm": 0, "Tentative": 0},
            "Information": {"Certain": 0, "Firm": 0, "Tentative": 0}
        }
        
        for f in context.findings:
            if f.type == FindingType.VULNERABILITY:
                sev = f.severity.value
                conf = f.confidence.value
                if sev in matrix and conf in matrix[sev]:
                    matrix[sev][conf] += 1

        with open(path, "w", encoding="utf-8") as f:
            f.write(f"# Executive Summary: {context.target_url}\n\n")
            f.write(f"**Date**: {context.scan_date.strftime('%d %b %Y')}\n\n")

            f.write(f"## 1. Resumen de Problemas (Summary)\n")
            f.write(f"BugtraceAI ha identificado los siguientes problemas clasificados por severidad y confianza.\n\n")

            f.write(f"### Tabla de Clasificaci√≥n (Severity vs Confidence)\n")
            f.write(f"| Severity | Certain | Firm | Tentative | Total |\n")
            f.write(f"| :--- | :--- | :--- | :--- | :--- |\n")
            
            total_high = sum(matrix["High"].values())
            total_med = sum(matrix["Medium"].values())
            total_low = sum(matrix["Low"].values())
            total_info = sum(matrix["Information"].values())
            
            f.write(f"| **High** | {matrix['High']['Certain']} | {matrix['High']['Firm']} | {matrix['High']['Tentative']} | **{total_high}** |\n")
            f.write(f"| **Medium** | {matrix['Medium']['Certain']} | {matrix['Medium']['Firm']} | {matrix['Medium']['Tentative']} | **{total_med}** |\n")
            f.write(f"| **Low** | {matrix['Low']['Certain']} | {matrix['Low']['Firm']} | {matrix['Low']['Tentative']} | **{total_low}** |\n")
            f.write(f"| **Information** | {matrix['Information']['Certain']} | {matrix['Information']['Firm']} | {matrix['Information']['Tentative']} | **{total_info}** |\n\n")

            f.write(f"## Nota sobre Privacidad (IAB TCF)\n")
            f.write(f"> **Privacy Notice**: El sitio y sus socios pueden almacenar y acceder a informaci√≥n en el dispositivo para publicidad personalizada, medici√≥n de contenido e investigaci√≥n de audiencia. Se procesan datos de geolocalizaci√≥n y caracter√≠sticas del dispositivo.\n\n")
