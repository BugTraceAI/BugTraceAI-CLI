import asyncio
import re
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from loguru import logger
import httpx
from bugtrace.agents.base import BaseAgent
from bugtrace.tools.external import external_tools
from bugtrace.tools.exploitation.sqli import sqli_detector

class SQLiAgent(BaseAgent):
    """
    Agent specialized in SQL Injection.
    Uses a hybrid approach: fast Python detection first, SQLMap fallback if needed.
    """
    def __init__(self, url: str = None, param: str = None, event_bus: Any = None):
        super().__init__("SQLiAgent", "SQL Injection Specialist", event_bus=event_bus, agent_id="sqli_agent")
        self.url = url
        self.param = param

    async def run_loop(self) -> Dict:
        logger.info(f"[{self.name}] Testing SQLi on {self.url}")

        findings = []

        # Fase 1: Deteccion Python (rapida, sin Docker) sobre parametros existentes
        python_result = await self._python_detection(self.url)
        if python_result:
            findings.extend(python_result)
            return {"vulnerable": True, "findings": findings}

        # Fase 2: Descubrimiento de nuevos parametros (solucion para L4)
        logger.info(f"[{self.name}] Stage 1 failed, searching for hidden parameters in page content...")
        try:
            async with httpx.AsyncClient() as client:
                resp = await client.get(self.url)
                page_content = resp.text
                discovered_params = self._discover_additional_params(page_content)
                
                for p in discovered_params:
                    # Si el parametro no esta ya en la URL, probarlo
                    parsed = urlparse(self.url)
                    existing_params = parse_qs(parsed.query)
                    if p not in existing_params:
                        logger.info(f"[{self.name}] Testing discovered parameter: {p}")
                        new_url = self._add_param_to_url(self.url, p, "1")
                        res = await self._python_detection(new_url)
                        if res:
                            findings.extend(res)
                            return {"vulnerable": True, "findings": findings}
        except Exception as e:
            logger.warning(f"[{self.name}] Parameter discovery failed: {e}")

        # Fase 3: Si Python falla, usar SQLMap (lento pero preciso)
        logger.info(f"[{self.name}] Python detection failed, falling back to SQLMap...")

        # Extraer parametros de la URL
        parsed = urlparse(self.url)
        params = parse_qs(parsed.query)

        # Usar el parámetro específico si se proporcionó, de lo contrario todos los de la URL
        target_params = [self.param] if self.param else list(params.keys())
        if not target_params:
             target_params = ["id"] # Fallback sensato

        for param in target_params:
            # Convertir localhost a IP accesible desde Docker
            docker_url = self.url.replace("127.0.0.1", "172.17.0.1").replace("localhost", "172.17.0.1")

            # Ejecutar SQLMap a través del wrapper de herramientas externas
            sqlmap_result = await external_tools.run_sqlmap(docker_url, target_param=param)

            if sqlmap_result and sqlmap_result.get("vulnerable"):
                findings.append({
                    "type": "SQLi",
                    "url": self.url,
                    "parameter": sqlmap_result.get("parameter", param),
                    "payload": "SQLMap confirmed",
                    "description": f"SQLMap detected {sqlmap_result.get('type', 'SQL Injection')}",
                    "severity": "CRITICAL",
                    "validated": True,
                    "tool": "sqlmap",
                    "reproduction": sqlmap_result.get("reproduction_command", "")
                })
                break 

        return {
            "vulnerable": len(findings) > 0,
            "findings": findings
        }

    async def _python_detection(self, url: str) -> List[Dict]:
        """Deteccion rapida con payloads Python (sin Docker)."""
        findings = []
        res = await sqli_detector.check(url)
        
        if res:
            msg, _ = res if isinstance(res, tuple) else (res, None)
            findings.append({
                "type": "SQLi",
                "url": url,
                "payload": msg,
                "description": f"Internal Python detector confirmed SQLi: {msg}",
                "severity": "CRITICAL",
                "validated": True,
                "tool": "internal_python"
            })
        return findings

    def _discover_additional_params(self, content: str) -> List[str]:
        """Extrae posibles nombres de parametros del contenido de la pagina."""
        patterns = [
            r"['\"](\w+)['\"]\s+parameter",
            r"parameter\s+['\"](\w+)['\"]",
        ]
        found = []
        for p in patterns:
            found.extend(re.findall(p, content, re.IGNORECASE))
        return list(set(found))

    def _add_param_to_url(self, url: str, param: str, value: str) -> str:
        parsed = urlparse(url)
        query = parse_qs(parsed.query)
        query[param] = [value]
        new_query = urlencode(query, doseq=True)
        return urlunparse(parsed._replace(query=new_query))
