from loguru import logger
from typing import Optional, Dict, Any, List
from bugtrace.tools.visual.browser import browser_manager
from bugtrace.core.ui import dashboard

class PrototypePollutionDetector:
    """
    Detects Client-Side Prototype Pollution by injecting into URL parameters
    and verifying DOM changes via Browser.
    """
    
    def __init__(self):
        self.payloads = [
            "?__proto__[bugtrace]=polluted",
            "?constructor[prototype][bugtrace]=polluted",
            "?__proto__.bugtrace=polluted"
        ]

    async def check(self, url: str) -> Optional[str]:
        """
        Navigates to the URL with pollution payloads and checks for success.
        """
        logger.info(f"Checking for Prototype Pollution at {url}...")

        for p in self.payloads:
            result = await self._test_pollution_payload(url, p)
            if result:
                return result

        return None

    async def _test_pollution_payload(self, url: str, payload: str) -> Optional[str]:
        """Test a single prototype pollution payload."""
        dashboard.log(f"âš¡ [Proto] Testing Payload: {payload}", "INFO")
        test_url = f"{url}{payload}" if "?" not in url else f"{url}&{payload[1:]}"

        try:
            # Use proper context manager to ensure browser is started
            async with browser_manager.get_page() as page:
                await page.goto(test_url, wait_until="networkidle", timeout=15000)

                # Check if property was polluted in the global scope
                is_polluted = await page.evaluate("() => window.bugtrace === 'polluted' || ({}).bugtrace === 'polluted'")

                if is_polluted:
                    return f"Vulnerable to Prototype Pollution: {payload}"
        except Exception as e:
            logger.debug(f"Proto pollution check failed for {payload}: {e}")

        return None

proto_detector = PrototypePollutionDetector()
