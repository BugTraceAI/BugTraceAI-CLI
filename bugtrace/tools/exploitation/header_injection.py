from loguru import logger
from typing import Optional, Tuple
import urllib.parse
from bugtrace.tools.visual.browser import browser_manager
from bugtrace.core.ui import dashboard
import time

class HeaderInjectionDetector:
    """
    Detects HTTP Response Header Injection (CRLF).
    """
    
    def __init__(self):
        self.payloads = [
            "e7ivl%0d%0aaihvf", # Burp generic
            "%0d%0aSet-Cookie: bugtrace=crlf"
        ]

    async def check(self, url: str) -> Optional[Tuple[str, Optional[str]]]:
        """
        Checks for CRLF Injection.
        """
        logger.info(f"Checking for Header Injection at {url}...")
        
        for p in self.payloads:
            dashboard.log(f"âš¡ [Header] Testing Payload: {p}", "INFO")
             # Try injecting into 'category' or 'searchTerm' or generic query
            if "category=" in url:
                test_url = url.replace("category=", f"category={p}")
            elif "?" in url:
                test_url = f"{url}&category={p}"
            else:
                test_url = f"{url}?category={p}"
                
            try:
                # Use proper context manager to ensure browser is started
                async with browser_manager.get_page() as page:
                    response = await page.goto(test_url, wait_until="commit", timeout=10000)
                    
                    if not response:
                        continue

                    headers = response.headers
                    
                    # Check for reflected header or split
                    # Note: Playwright headers dict keys are lower-case
                    
                    # Weak Check: If payload string appears in any header value (unlikely for CRLF but checked)
                    # Strong Check: Did we successfully set a cookie?
                    if "bugtrace=crlf" in str(headers) or "aihvf" in str(headers):
                         return (f"Vulnerable to Header Injection: {p}", None)

            except Exception as e:
                # NOTE: HTTP/2 Protocol Error on CRLF is NOT a reliable indicator
                # It often indicates malformed request, not a true vulnerability
                # We log it for investigation but DO NOT report as confirmed vulnerability
                if "ERR_HTTP2_PROTOCOL_ERROR" in str(e) or "INVALID_HTTP_HEADER" in str(e):
                    logger.debug(f"Protocol error during header injection test ({p}) - not a confirmed vulnerability")
                else:
                    logger.debug(f"Header check failed for {p}: {e}")
                
        return None

header_detector = HeaderInjectionDetector()
