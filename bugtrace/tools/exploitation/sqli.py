"""
SQLInjectionDetector v2 - Improved SQL Injection Detection

IMPROVEMENTS (2026-01-23):
1. Triple Time-Based Verification - Reduces false positives from network latency
2. More Error Signatures - Better database fingerprinting
3. Time-Based marked as PENDING - Not confirmed without triple verification
4. Improved Boolean Analysis - Better similarity thresholds
"""

from loguru import logger
import re
from typing import Optional, Tuple, Dict, List
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import difflib
import time
from bugtrace.tools.visual.browser import browser_manager
from bugtrace.core.ui import dashboard
from bugtrace.core.llm_client import llm_client
from bugtrace.core.conductor import conductor
from bugtrace.utils.parsers import XmlParser


# =============================================================================
# ERROR SIGNATURES BY DATABASE
# =============================================================================

ERROR_SIGNATURES = {
    "MySQL": [
        "SQL syntax", "mysql_fetch", "Warning: mysql", "MySQLSyntaxErrorException",
        "valid MySQL result", "check the manual that corresponds to your MySQL",
        "MySqlClient.", "com.mysql.jdbc", "Syntax error.*MySQL",
        "You have an error in your SQL syntax", "mysql_num_rows",
        "mysql_query", "mysqli_", "MariaDB"
    ],
    "PostgreSQL": [
        "postgresql", "pg_", "PSQLException", "org.postgresql",
        "ERROR:  syntax error at or near", "valid PostgreSQL result",
        "Npgsql.", "PG::SyntaxError", "unterminated quoted string"
    ],
    "MSSQL": [
        "ODBC SQL Server Driver", "SqlException", "Unclosed quotation mark",
        "Microsoft SQL Server", "SQLServer JDBC Driver", "Incorrect syntax near",
        "mssql", "Procedure.*expects parameter", "[Microsoft][ODBC",
        "SQL Server.*Driver", "Warning.*mssql_"
    ],
    "Oracle": [
        "ORA-", "Oracle.*Driver", "quoted string not properly terminated",
        "oracle.jdbc", "SQL command not properly ended", "PLS-",
        "TNS:", "SP2-"
    ],
    "SQLite": [
        "SQLite", "sqlite3.OperationalError", "unrecognized token",
        "SQLITE_ERROR", "unable to open database file",
        "near \".*\": syntax error"
    ],
    "Generic": [
        "ERROR:", "SQL syntax", "sql error", "database error",
        "query failed", "syntax error", "Invalid query",
        "injection possible", "vulnerable to"
    ]
}


class SQLInjectionDetector:
    """
    Detects SQL Injection (Error-Based & Boolean-Based Blind).
    Uses browser for rendering to catch DOM-based or complex reflected changes.

    IMPROVED (2026-01-23):
    - Triple verification for time-based to reduce false positives
    - Better error signature matching with database fingerprinting
    - Time-based returns PENDING status, not CONFIRMED
    """

    def __init__(self):
        # Flatten all signatures for quick matching
        self.error_signatures = []
        for db_sigs in ERROR_SIGNATURES.values():
            self.error_signatures.extend(db_sigs)
        self.error_signatures = list(set(self.error_signatures))

    async def check(self, url: str) -> Optional[Tuple[str, str]]:
        """
        Checks a specific URL for SQLi using Error and Boolean heuristics.
        Returns (Message, ScreenshotPath) or None.
        """
        logger.info(f"Checking for SQLi at {url}...")

        parsed = urlparse(url)
        params = parse_qs(parsed.query)

        if not params:
            return None

        async with browser_manager.get_page() as page:
            # 1. Baseline Request
            try:
                start_time = time.time()
                base_resp = await page.goto(url, wait_until="domcontentloaded", timeout=10000)
                baseline_duration = time.time() - start_time

                if not base_resp or base_resp.status >= 400:
                    return None
                base_content = await page.content()
            except Exception as e:
                logger.warning(f"Baseline failed for {url}: {e}")
                return None

            # Iterate over each parameter
            for param_name in params.keys():
                original_value = params[param_name][0]

                # --- A. Error-Based Check (HIGHEST CONFIDENCE) ---
                error_payload = "'"
                error_result = await self._test_error_based(
                    page, url, param_name, original_value, error_payload
                )
                if error_result:
                    return error_result

                # Try more error payloads
                additional_error_payloads = ["''", "\"", "' OR '1'='1", "1'", "1\""]
                for payload in additional_error_payloads:
                    error_result = await self._test_error_based(
                        page, url, param_name, original_value, payload
                    )
                    if error_result:
                        return error_result

                # --- B. Boolean-Based Blind Check (HIGH CONFIDENCE) ---
                boolean_result = await self._test_boolean_based(
                    page, url, param_name, original_value, base_content
                )
                if boolean_result:
                    return boolean_result

                # --- C. AI-Enhanced Check (MEDIUM CONFIDENCE) ---
                ai_result = await self._llm_check(
                    page, url, param_name, original_value, baseline_duration
                )
                if ai_result:
                    return ai_result

        return None

    async def _test_error_based(
        self, page, url: str, param: str, original_value: str, payload: str
    ) -> Optional[Tuple[str, str]]:
        """
        Test for error-based SQL injection.
        Returns confirmed finding if SQL error detected.
        """
        target_url = self._build_url(url, param, original_value + payload)
        try:
            resp = await page.goto(target_url, wait_until="domcontentloaded", timeout=5000)
            content = await page.content()

            # Check HTTP 500
            if resp.status == 500:
                db_type = self._fingerprint_database(content)
                return await self._confirm_vuln(
                    page,
                    f"Error-Based SQLi ({db_type or 'Unknown DB'})",
                    f"Payload: {payload}, HTTP 500 triggered",
                    confidence="HIGH"
                )

            # Check error signatures
            db_type = self._fingerprint_database(content)
            if db_type:
                return await self._confirm_vuln(
                    page,
                    f"Error-Based SQLi ({db_type})",
                    f"Payload: {payload}, DB error detected",
                    confidence="HIGH"
                )

        except Exception as e:
            logger.debug(f"Error-based test failed: {e}")

        return None

    async def _test_boolean_based(
        self, page, url: str, param: str, original_value: str, base_content: str
    ) -> Optional[Tuple[str, str]]:
        """
        Test for boolean-based blind SQL injection.
        Uses improved similarity analysis.
        """
        try:
            # True condition - should match baseline
            true_payload = " AND 1=1"
            true_url = self._build_url(url, param, original_value + true_payload)
            await page.goto(true_url, wait_until="domcontentloaded", timeout=5000)
            true_content = await page.content()

            # False condition - should differ from baseline
            false_payload = " AND 1=0"
            false_url = self._build_url(url, param, original_value + false_payload)
            await page.goto(false_url, wait_until="domcontentloaded", timeout=5000)
            false_content = await page.content()

            # Calculate similarity
            sim_true = difflib.SequenceMatcher(None, base_content, true_content).ratio()
            sim_false = difflib.SequenceMatcher(None, base_content, false_content).ratio()
            diff_ratio = abs(sim_true - sim_false)

            dashboard.log(
                f"[{param}] Boolean: True={sim_true:.2f}, False={sim_false:.2f}, Diff={diff_ratio:.2f}",
                "DEBUG"
            )

            # IMPROVED: More nuanced thresholds
            # True should be very similar (>0.95), False should be different (<0.85)
            # AND the difference should be significant (>0.15)
            if sim_true > 0.95 and sim_false < 0.85 and diff_ratio > 0.15:
                return await self._confirm_vuln(
                    page,
                    "Boolean-Based Blind SQLi",
                    f"Param: {param}, True/False diff: {diff_ratio:.2f}",
                    confidence="HIGH"
                )

            # Lower confidence: less strict thresholds
            if sim_true > 0.90 and sim_false < 0.90 and diff_ratio > 0.10:
                return await self._confirm_vuln(
                    page,
                    "Boolean-Based Blind SQLi (Low Confidence)",
                    f"Param: {param}, True/False diff: {diff_ratio:.2f}",
                    confidence="MEDIUM"
                )

        except Exception as e:
            logger.debug(f"Boolean-based test failed: {e}")

        return None

    async def _verify_time_based_triple(
        self, page, url: str, param: str, original_value: str,
        payload_template: str, baseline_duration: float
    ) -> Tuple[bool, Dict]:
        """
        Triple verification for time-based SQLi to reduce false positives.

        1. Baseline (no sleep) - should match baseline_duration
        2. Short sleep (3s) - should take ~3s longer
        3. Long sleep (8s) - should take ~8s longer

        Returns (is_vulnerable, evidence)
        """
        evidence = {
            "baseline_time": baseline_duration,
            "short_sleep_time": 0,
            "long_sleep_time": 0,
            "triple_verified": False
        }

        # If baseline is already slow (>3s), skip time-based (unreliable)
        if baseline_duration > 3:
            logger.debug(f"Baseline too slow ({baseline_duration:.1f}s), skipping time-based")
            return False, evidence

        try:
            # Short sleep (3 seconds)
            short_payload = payload_template.replace("5", "3").replace("10", "3")
            short_url = self._build_url(url, param, original_value + short_payload)

            start = time.time()
            await page.goto(short_url, wait_until="domcontentloaded", timeout=15000)
            short_time = time.time() - start
            evidence["short_sleep_time"] = short_time

            # Long sleep (8 seconds)
            long_payload = payload_template.replace("5", "8").replace("3", "8")
            long_url = self._build_url(url, param, original_value + long_payload)

            start = time.time()
            await page.goto(long_url, wait_until="domcontentloaded", timeout=20000)
            long_time = time.time() - start
            evidence["long_sleep_time"] = long_time

            # Verify correlation: baseline < short < long
            # With reasonable tolerances for network variance
            baseline_tolerance = baseline_duration + 1  # Allow 1s variance

            if (short_time > baseline_tolerance + 2 and  # At least 2s more than baseline
                long_time > short_time + 3 and           # At least 3s more than short
                short_time < 7 and                       # Short should be around 3-6s
                long_time > 7):                          # Long should be >7s

                evidence["triple_verified"] = True
                logger.info(
                    f"Time-based TRIPLE VERIFIED: base={baseline_duration:.1f}s, "
                    f"short={short_time:.1f}s, long={long_time:.1f}s"
                )
                return True, evidence

            logger.debug(
                f"Time-based verification FAILED: base={baseline_duration:.1f}s, "
                f"short={short_time:.1f}s, long={long_time:.1f}s"
            )
            return False, evidence

        except Exception as e:
            logger.debug(f"Time-based verification error: {e}")
            return False, evidence

    async def _llm_check(
        self, page, url: str, param: str, original_value: str, baseline_duration: float
    ) -> Optional[Tuple[str, str]]:
        """
        AI-enhanced check with improved time-based verification.
        """
        dashboard.update_task("SQLi Agent", status=f"AI Thinking: {param}...")

        system_prompt = conductor.get_full_system_prompt()
        if system_prompt:
            if "## SQLi Detection Prompt" in system_prompt:
                system_prompt = system_prompt.split("## SQLi Detection Prompt")[-1].strip()
            system_prompt = re.sub(r'```xml\n?', '', system_prompt)
            system_prompt = re.sub(r'```\n?', '', system_prompt)
        else:
            system_prompt = """You are an expert SQL Injection specialist.
Generate 3 advanced SQL injection payloads for the specified parameter.
Focus on:
1. Error-based payloads (trigger SQL errors)
2. Boolean-based payloads (1=1 vs 1=0)
3. Union-based payloads (UNION SELECT)

IMPORTANT: Avoid time-based payloads (SLEEP) as they are unreliable.

Return XML format:
<payloads>
  <payload>
    <content>' UNION SELECT NULL,NULL--</content>
    <type>Union-Based</type>
  </payload>
</payloads>"""

        user_prompt = f"""Target: {url}
Parameter: {param}
Value: {original_value}

Generate 3 payloads to detect SQLi here. Prefer error-based and union-based over time-based."""

        try:
            response = await llm_client.generate(
                prompt=user_prompt,
                system_prompt=system_prompt,
                module_name="SQLAgent",
                max_tokens=1000
            )

            if not response:
                return None

            payload_nodes = XmlParser.extract_list(response, "payload")

            for node in payload_nodes:
                payload_content = XmlParser.extract_tag(node, "content")
                payload_type = XmlParser.extract_tag(node, "type") or "Unknown"

                if not payload_content:
                    continue

                dashboard.update_task("SQLi Agent", status=f"AI Testing: {payload_content[:20]}...")

                # Test the payload
                target_url = self._build_url(url, param, payload_content)

                start_t = time.time()
                try:
                    resp = await page.goto(target_url, wait_until="domcontentloaded", timeout=15000)
                    content = await page.content()
                    duration = time.time() - start_t
                except Exception as e:
                    logger.debug(f"SQLi payload navigation failed: {e}")
                    continue

                # Check for error signatures
                db_type = self._fingerprint_database(content)
                if db_type:
                    return await self._confirm_vuln(
                        page,
                        f"AI-Detected SQLi (Error-Based, {db_type})",
                        f"Payload: {payload_content}",
                        confidence="HIGH"
                    )

                # Check HTTP 500
                if resp.status == 500:
                    return await self._confirm_vuln(
                        page,
                        "AI-Detected SQLi (HTTP 500)",
                        f"Payload: {payload_content}",
                        confidence="HIGH"
                    )

                # IMPROVED: Time-based requires triple verification
                if "SLEEP" in payload_content.upper() or "WAITFOR" in payload_content.upper():
                    # Only verify if initial response was slow
                    if duration > baseline_duration + 3:
                        verified, evidence = await self._verify_time_based_triple(
                            page, url, param, original_value, payload_content, baseline_duration
                        )
                        if verified:
                            return await self._confirm_vuln(
                                page,
                                "AI-Detected SQLi (Time-Based, Triple Verified)",
                                f"Payload: {payload_content}, Evidence: {evidence}",
                                confidence="MEDIUM"  # Still medium because time-based
                            )
                        else:
                            # Log but don't confirm - likely false positive
                            logger.debug(
                                f"Time-based NOT verified: {payload_content} "
                                f"(duration={duration:.1f}s but triple check failed)"
                            )

        except Exception as e:
            logger.error(f"AI SQLi check failed: {e}")

        return None

    def _fingerprint_database(self, content: str) -> Optional[str]:
        """
        Fingerprint database type from error messages.
        Returns database name or None.
        """
        if not content:
            return None

        content_lower = content.lower()

        for db_name, signatures in ERROR_SIGNATURES.items():
            if db_name == "Generic":
                continue  # Check generic last
            for sig in signatures:
                if sig.lower() in content_lower:
                    return db_name

        # Check generic patterns
        for sig in ERROR_SIGNATURES["Generic"]:
            if sig.lower() in content_lower:
                return "Unknown"

        return None

    async def _confirm_vuln(
        self, page, vuln_type: str, details: str, confidence: str = "HIGH"
    ) -> Tuple[str, Optional[str]]:
        """
        Returns confirmation message with confidence level.
        """
        msg = f"{vuln_type}: {details} [Confidence: {confidence}]"
        logger.warning(msg)

        # SQLi doesn't need screenshots - evidence is in error messages/behavior
        return msg, None

    def _build_url(self, base_url: str, param: str, new_value: str) -> str:
        """Reconstructs URL with new parameter value."""
        parsed = urlparse(base_url)
        q = parse_qs(parsed.query)
        q[param] = [new_value]
        new_query = urlencode(q, doseq=True)
        return urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))


sqli_detector = SQLInjectionDetector()
