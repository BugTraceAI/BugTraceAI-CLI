"""
SQLInjectionDetector v2 - Improved SQL Injection Detection

IMPROVEMENTS (2026-01-23):
1. Triple Time-Based Verification - Reduces false positives from network latency
2. More Error Signatures - Better database fingerprinting
3. Time-Based marked as PENDING - Not confirmed without triple verification
4. Improved Boolean Analysis - Better similarity thresholds
"""

from loguru import logger
import re
from typing import Optional, Tuple, Dict, List
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import difflib
import time
from bugtrace.tools.visual.browser import browser_manager
from bugtrace.core.ui import dashboard
from bugtrace.core.llm_client import llm_client
from bugtrace.core.conductor import conductor
from bugtrace.utils.parsers import XmlParser


# =============================================================================
# ERROR SIGNATURES BY DATABASE
# =============================================================================

ERROR_SIGNATURES = {
    "MySQL": [
        "SQL syntax", "mysql_fetch", "Warning: mysql", "MySQLSyntaxErrorException",
        "valid MySQL result", "check the manual that corresponds to your MySQL",
        "MySqlClient.", "com.mysql.jdbc", "Syntax error.*MySQL",
        "You have an error in your SQL syntax", "mysql_num_rows",
        "mysql_query", "mysqli_", "MariaDB"
    ],
    "PostgreSQL": [
        "postgresql", "pg_", "PSQLException", "org.postgresql",
        "ERROR:  syntax error at or near", "valid PostgreSQL result",
        "Npgsql.", "PG::SyntaxError", "unterminated quoted string"
    ],
    "MSSQL": [
        "ODBC SQL Server Driver", "SqlException", "Unclosed quotation mark",
        "Microsoft SQL Server", "SQLServer JDBC Driver", "Incorrect syntax near",
        "mssql", "Procedure.*expects parameter", "[Microsoft][ODBC",
        "SQL Server.*Driver", "Warning.*mssql_"
    ],
    "Oracle": [
        "ORA-", "Oracle.*Driver", "quoted string not properly terminated",
        "oracle.jdbc", "SQL command not properly ended", "PLS-",
        "TNS:", "SP2-"
    ],
    "SQLite": [
        "SQLite", "sqlite3.OperationalError", "unrecognized token",
        "SQLITE_ERROR", "unable to open database file",
        "near \".*\": syntax error"
    ],
    "Generic": [
        "ERROR:", "SQL syntax", "sql error", "database error",
        "query failed", "syntax error", "Invalid query",
        "injection possible", "vulnerable to"
    ]
}


class SQLInjectionDetector:
    """
    Detects SQL Injection (Error-Based & Boolean-Based Blind).
    Uses browser for rendering to catch DOM-based or complex reflected changes.

    IMPROVED (2026-01-23):
    - Triple verification for time-based to reduce false positives
    - Better error signature matching with database fingerprinting
    - Time-based returns PENDING status, not CONFIRMED
    """

    def __init__(self):
        # Flatten all signatures for quick matching
        self.error_signatures = []
        for db_sigs in ERROR_SIGNATURES.values():
            self.error_signatures.extend(db_sigs)
        self.error_signatures = list(set(self.error_signatures))

    async def check(self, url: str) -> Optional[Tuple[str, str]]:
        """
        Checks a specific URL for SQLi using Error and Boolean heuristics.
        Returns (Message, ScreenshotPath) or None.
        """
        logger.info(f"Checking for SQLi at {url}...")

        parsed = urlparse(url)
        params = parse_qs(parsed.query)

        if not params:
            return None

        async with browser_manager.get_page() as page:
            baseline_result = await self._establish_baseline(page, url)
            if not baseline_result:
                return None

            base_content, baseline_duration = baseline_result

            for param_name in params.keys():
                original_value = params[param_name][0]

                result = await self._test_parameter_for_sqli(
                    page, url, param_name, original_value, base_content, baseline_duration
                )
                if result:
                    return result

        return None

    async def _establish_baseline(self, page, url: str) -> Optional[Tuple[str, float]]:
        """Establish baseline response for comparison."""
        try:
            start_time = time.time()
            base_resp = await page.goto(url, wait_until="domcontentloaded", timeout=10000)
            baseline_duration = time.time() - start_time

            if not base_resp or base_resp.status >= 400:
                return None

            base_content = await page.content()
            return base_content, baseline_duration
        except Exception as e:
            logger.warning(f"Baseline failed for {url}: {e}")
            return None

    async def _test_parameter_for_sqli(
        self, page, url: str, param_name: str, original_value: str,
        base_content: str, baseline_duration: float
    ) -> Optional[Tuple[str, str]]:
        """Test single parameter for all SQLi types."""
        # Error-based checks (highest confidence)
        error_result = await self._test_all_error_payloads(page, url, param_name, original_value)
        if error_result:
            return error_result

        # Boolean-based blind check
        boolean_result = await self._test_boolean_based(page, url, param_name, original_value, base_content)
        if boolean_result:
            return boolean_result

        # AI-enhanced check
        return await self._llm_check(page, url, param_name, original_value, baseline_duration)

    async def _test_all_error_payloads(
        self, page, url: str, param_name: str, original_value: str
    ) -> Optional[Tuple[str, str]]:
        """Test all error-based payloads."""
        error_payloads = ["'", "''", "\"", "' OR '1'='1", "1'", "1\""]
        for payload in error_payloads:
            result = await self._test_error_based(page, url, param_name, original_value, payload)
            if result:
                return result
        return None

    async def _test_error_based(
        self, page, url: str, param: str, original_value: str, payload: str
    ) -> Optional[Tuple[str, str]]:
        """
        Test for error-based SQL injection.
        Returns confirmed finding if SQL error detected.
        """
        target_url = self._build_url(url, param, original_value + payload)
        try:
            resp = await page.goto(target_url, wait_until="domcontentloaded", timeout=5000)
            content = await page.content()

            # Check HTTP 500
            if resp.status == 500:
                db_type = self._fingerprint_database(content)
                return await self._confirm_vuln(
                    page,
                    f"Error-Based SQLi ({db_type or 'Unknown DB'})",
                    f"Payload: {payload}, HTTP 500 triggered",
                    confidence="HIGH"
                )

            # Check error signatures
            db_type = self._fingerprint_database(content)
            if db_type:
                return await self._confirm_vuln(
                    page,
                    f"Error-Based SQLi ({db_type})",
                    f"Payload: {payload}, DB error detected",
                    confidence="HIGH"
                )

        except Exception as e:
            logger.debug(f"Error-based test failed: {e}")

        return None

    async def _test_boolean_based(
        self, page, url: str, param: str, original_value: str, base_content: str
    ) -> Optional[Tuple[str, str]]:
        """
        Test for boolean-based blind SQL injection.
        Uses improved similarity analysis.
        """
        try:
            true_content = await self._fetch_boolean_response(page, url, param, original_value, " AND 1=1")
            false_content = await self._fetch_boolean_response(page, url, param, original_value, " AND 1=0")

            sim_true = difflib.SequenceMatcher(None, base_content, true_content).ratio()
            sim_false = difflib.SequenceMatcher(None, base_content, false_content).ratio()
            diff_ratio = abs(sim_true - sim_false)

            dashboard.log(
                f"[{param}] Boolean: True={sim_true:.2f}, False={sim_false:.2f}, Diff={diff_ratio:.2f}",
                "DEBUG"
            )

            return self._evaluate_boolean_similarity(page, param, sim_true, sim_false, diff_ratio)

        except Exception as e:
            logger.debug(f"Boolean-based test failed: {e}")
            return None

    async def _fetch_boolean_response(self, page, url: str, param: str, original_value: str, payload: str) -> str:
        """Fetch response for boolean payload."""
        test_url = self._build_url(url, param, original_value + payload)
        await page.goto(test_url, wait_until="domcontentloaded", timeout=5000)
        return await page.content()

    async def _evaluate_boolean_similarity(
        self, page, param: str, sim_true: float, sim_false: float, diff_ratio: float
    ) -> Optional[Tuple[str, str]]:
        """Evaluate boolean similarity ratios and determine vulnerability."""
        # High confidence: strict thresholds
        if sim_true > 0.95 and sim_false < 0.85 and diff_ratio > 0.15:
            return await self._confirm_vuln(
                page,
                "Boolean-Based Blind SQLi",
                f"Param: {param}, True/False diff: {diff_ratio:.2f}",
                confidence="HIGH"
            )

        # Medium confidence: relaxed thresholds
        if sim_true > 0.90 and sim_false < 0.90 and diff_ratio > 0.10:
            return await self._confirm_vuln(
                page,
                "Boolean-Based Blind SQLi (Low Confidence)",
                f"Param: {param}, True/False diff: {diff_ratio:.2f}",
                confidence="MEDIUM"
            )

        return None

    async def _verify_time_based_triple(
        self, page, url: str, param: str, original_value: str,
        payload_template: str, baseline_duration: float
    ) -> Tuple[bool, Dict]:
        """
        Triple verification for time-based SQLi to reduce false positives.

        1. Baseline (no sleep) - should match baseline_duration
        2. Short sleep (3s) - should take ~3s longer
        3. Long sleep (8s) - should take ~8s longer

        Returns (is_vulnerable, evidence)
        """
        evidence = {
            "baseline_time": baseline_duration,
            "short_sleep_time": 0,
            "long_sleep_time": 0,
            "triple_verified": False
        }

        # If baseline is already slow (>3s), skip time-based (unreliable)
        if baseline_duration > 3:
            logger.debug(f"Baseline too slow ({baseline_duration:.1f}s), skipping time-based")
            return False, evidence

        try:
            short_time = await self._measure_sleep_response(page, url, param, original_value, payload_template, 3, 15000)
            evidence["short_sleep_time"] = short_time

            long_time = await self._measure_sleep_response(page, url, param, original_value, payload_template, 8, 20000)
            evidence["long_sleep_time"] = long_time

            is_verified = self._validate_time_correlation(baseline_duration, short_time, long_time)
            evidence["triple_verified"] = is_verified

            if is_verified:
                logger.info(f"Time-based TRIPLE VERIFIED: base={baseline_duration:.1f}s, short={short_time:.1f}s, long={long_time:.1f}s")
            else:
                logger.debug(f"Time-based verification FAILED: base={baseline_duration:.1f}s, short={short_time:.1f}s, long={long_time:.1f}s")

            return is_verified, evidence

        except Exception as e:
            logger.debug(f"Time-based verification error: {e}")
            return False, evidence

    async def _measure_sleep_response(
        self, page, url: str, param: str, original_value: str, payload_template: str, sleep_seconds: int, timeout: int
    ) -> float:
        """Measure response time for a sleep payload."""
        payload = payload_template.replace("5", str(sleep_seconds)).replace("10", str(sleep_seconds)).replace("3", str(sleep_seconds))
        test_url = self._build_url(url, param, original_value + payload)
        start = time.time()
        await page.goto(test_url, wait_until="domcontentloaded", timeout=timeout)
        return time.time() - start

    def _validate_time_correlation(self, baseline: float, short: float, long: float) -> bool:
        """Validate that timing follows expected pattern for SQLi."""
        baseline_tolerance = baseline + 1

        return (
            short > baseline_tolerance + 2 and  # At least 2s more than baseline
            long > short + 3 and                # At least 3s more than short
            short < 7 and                       # Short should be around 3-6s
            long > 7                            # Long should be >7s
        )

    async def _llm_check(
        self, page, url: str, param: str, original_value: str, baseline_duration: float
    ) -> Optional[Tuple[str, str]]:
        """
        AI-enhanced check with improved time-based verification.
        """
        dashboard.update_task("SQLi Agent", status=f"AI Thinking: {param}...")

        system_prompt = self._get_sqli_system_prompt()
        user_prompt = f"Target: {url}\nParameter: {param}\nValue: {original_value}\n\nGenerate 3 payloads to detect SQLi here. Prefer error-based and union-based over time-based."

        try:
            response = await llm_client.generate(
                prompt=user_prompt,
                system_prompt=system_prompt,
                module_name="SQLAgent",
                max_tokens=1000
            )

            if not response:
                return None

            payload_nodes = XmlParser.extract_list(response, "payload")
            return await self._test_llm_payloads(page, url, param, original_value, baseline_duration, payload_nodes)

        except Exception as e:
            logger.error(f"AI SQLi check failed: {e}")
            return None

    def _get_sqli_system_prompt(self) -> str:
        """Get system prompt for SQLi detection."""
        system_prompt = conductor.get_full_system_prompt()
        if system_prompt:
            if "## SQLi Detection Prompt" in system_prompt:
                system_prompt = system_prompt.split("## SQLi Detection Prompt")[-1].strip()
            system_prompt = re.sub(r'```xml\n?', '', system_prompt)
            system_prompt = re.sub(r'```\n?', '', system_prompt)
        else:
            system_prompt = """You are an expert SQL Injection specialist.
Generate 3 advanced SQL injection payloads for the specified parameter.
Focus on:
1. Error-based payloads (trigger SQL errors)
2. Boolean-based payloads (1=1 vs 1=0)
3. Union-based payloads (UNION SELECT)

IMPORTANT: Avoid time-based payloads (SLEEP) as they are unreliable.

Return XML format:
<payloads>
  <payload>
    <content>' UNION SELECT NULL,NULL--</content>
    <type>Union-Based</type>
  </payload>
</payloads>"""
        return system_prompt

    async def _test_llm_payloads(
        self, page, url: str, param: str, original_value: str, baseline_duration: float, payload_nodes: List
    ) -> Optional[Tuple[str, str]]:
        """Test LLM-generated payloads."""
        for node in payload_nodes:
            payload_content = XmlParser.extract_tag(node, "content")
            if not payload_content:
                continue

            dashboard.update_task("SQLi Agent", status=f"AI Testing: {payload_content[:20]}...")

            result = await self._test_single_llm_payload(
                page, url, param, original_value, payload_content, baseline_duration
            )
            if result:
                return result

        return None

    async def _test_single_llm_payload(
        self, page, url: str, param: str, original_value: str, payload_content: str, baseline_duration: float
    ) -> Optional[Tuple[str, str]]:
        """Test a single LLM-generated payload."""
        target_url = self._build_url(url, param, payload_content)

        try:
            start_t = time.time()
            resp = await page.goto(target_url, wait_until="domcontentloaded", timeout=15000)
            content = await page.content()
            duration = time.time() - start_t
        except Exception as e:
            logger.debug(f"SQLi payload navigation failed: {e}")
            return None

        # Check for error-based indicators
        db_type = self._fingerprint_database(content)
        if db_type:
            return await self._confirm_vuln(page, f"AI-Detected SQLi (Error-Based, {db_type})", f"Payload: {payload_content}", confidence="HIGH")

        if resp.status == 500:
            return await self._confirm_vuln(page, "AI-Detected SQLi (HTTP 500)", f"Payload: {payload_content}", confidence="HIGH")

        # Check time-based with triple verification
        if "SLEEP" in payload_content.upper() or "WAITFOR" in payload_content.upper():
            return await self._verify_and_confirm_time_based(
                page, url, param, original_value, payload_content, duration, baseline_duration
            )

        return None

    async def _verify_and_confirm_time_based(
        self, page, url: str, param: str, original_value: str, payload_content: str, duration: float, baseline_duration: float
    ) -> Optional[Tuple[str, str]]:
        """Verify and confirm time-based SQLi."""
        if duration > baseline_duration + 3:
            verified, evidence = await self._verify_time_based_triple(
                page, url, param, original_value, payload_content, baseline_duration
            )
            if verified:
                return await self._confirm_vuln(
                    page,
                    "AI-Detected SQLi (Time-Based, Triple Verified)",
                    f"Payload: {payload_content}, Evidence: {evidence}",
                    confidence="MEDIUM"
                )
            else:
                logger.debug(f"Time-based NOT verified: {payload_content} (duration={duration:.1f}s but triple check failed)")

        return None

    def _fingerprint_database(self, content: str) -> Optional[str]:
        """
        Fingerprint database type from error messages.
        Returns database name or None.
        """
        if not content:
            return None

        content_lower = content.lower()

        for db_name, signatures in ERROR_SIGNATURES.items():
            if db_name == "Generic":
                continue  # Check generic last
            for sig in signatures:
                if sig.lower() in content_lower:
                    return db_name

        # Check generic patterns
        for sig in ERROR_SIGNATURES["Generic"]:
            if sig.lower() in content_lower:
                return "Unknown"

        return None

    async def _confirm_vuln(
        self, page, vuln_type: str, details: str, confidence: str = "HIGH"
    ) -> Tuple[str, Optional[str]]:
        """
        Returns confirmation message with confidence level.
        """
        msg = f"{vuln_type}: {details} [Confidence: {confidence}]"
        logger.warning(msg)

        # SQLi doesn't need screenshots - evidence is in error messages/behavior
        return msg, None

    def _build_url(self, base_url: str, param: str, new_value: str) -> str:
        """Reconstructs URL with new parameter value."""
        parsed = urlparse(base_url)
        q = parse_qs(parsed.query)
        q[param] = [new_value]
        new_query = urlencode(q, doseq=True)
        return urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))


sqli_detector = SQLInjectionDetector()
