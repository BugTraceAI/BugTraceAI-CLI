# ExploitAgent Event Bus Migration Guide
## PASO 4 - Completion Instructions | 2026-01-01

---

## STATUS: üü° SKELETON CREATED - Awaiting Implementation

**Progress**: 50% (Structure complete, logic pending)  
**Estimated Completion Time**: 1-2 hours  
**Testing Required**: Yes (manual + E2E)

---

## WHAT WAS DONE

### ‚úÖ Completed (Skeleton)

1. **Constructor Updated**
   - Added `event_bus` parameter
   - Passes to BaseAgent
   - File: `bugtrace/agents/exploit.py:31-38`

2. **Event Subscriptions Setup**
   - `_setup_event_subscriptions()` created
   - Subscribes to `new_input_discovered`
   - File: `bugtrace/agents/exploit.py:40-48`

3. **Cleanup Method Added**
   - `_cleanup_event_subscriptions()` created
   - Unsubscribes on agent stop
   - File: `bugtrace/agents/exploit.py:50-57`

4. **Handler Skeleton Created**
   - `handle_new_input(data)` method added
   - Complete documentation in docstring
   - TODO comments for implementation
   - File: `bugtrace/agents/exploit.py:59-130`

5. **run_loop() Documented**
   - Explained transition strategy
   - Kept polling (backward compatible)
   - TODOs for migration
   - File: `bugtrace/agents/exploit.py:132-238`

---

## TODO: COMPLETE IMPLEMENTATION

### Step 1: Implement handle_new_input() Logic

**File**: `bugtrace/agents/exploit.py:59-130`

**Current State**: Skeleton with TODOs

**What to Implement**:

```python
async def handle_new_input(self, data: dict):
    """Handler for new_input_discovered events."""
    
    # 1. Extract data
    url = data.get('url', '')
    input_details = data.get('input', {})
    input_label = input_details.get('name', 'unknown')
    input_type = input_details.get('type', '')
    
    logger.info(f"[{self.name}] EVENT: Testing {input_label} at {url}")
    
    # 2. Check if already tested (deduplication)
    test_key = f"{url}:{input_label}"
    if test_key in self.tested_vectors:
        logger.debug(f"[{self.name}] Already tested, skipping")
        return
    
    # 3. Mark as testing in memory (optional, for tracking)
    # memory_manager.update_node_property(...)
    
    # 4. Add to tested set
    self.tested_vectors.add(test_key)
    
    # 5. Run ladder logic (COPY FROM OLD run_loop)
    try:
        dashboard.update_task(self.name, status=f"Testing: {input_label}")
        
        # WAF check
        await self._check_waf(url)
        
        # Skip if SAFE_MODE
        if settings.SAFE_MODE:
            logger.info(f"[{self.name}] SAFE_MODE: Skipping active tests")
            return
        
        # Run specific ladders based on input type/URL
        if "search" in url or "q=" in url or input_type == "text":
            await self._ladder_ui_attacks(url, input_label)
        
        if "id=" in url or "cat=" in url:
            await self._ladder_sqli(url)
        
        await self._ladder_infrastructure(url)
        
        logger.success(f"[{self.name}] Completed testing {input_label}")
        
    except Exception as e:
        logger.error(f"[{self.name}] Handler error: {e}", exc_info=True)
```

**Copy Logic From**: Lines 86-110 of old `run_loop()`

**Time Estimate**: 30 minutes

---

### Step 2: Emit vulnerability_detected Events

**Location**: Inside `_ladder_ui_attacks()` and `_ladder_sqli()`

**Current Code** (line ~180):
```python
# Stores in memory but doesn't emit event
memory_manager.add_node("FindingCandidate", f"xss_{label}", {
    "url": url, "payload": mutated, "status": "FIRED", "type": "XSS"
})
```

**Add After**:
```python
# NEW: Emit event for SkepticalAgent
await self.event_bus.emit("vulnerability_detected", {
    "finding_id": f"xss_{label}",
    "type": "XSS",
    "url": url,
    "payload": mutated,
    "confidence": 0.8,
    "detected_by": self.name,
    "timestamp": datetime.now().isoformat()
})

logger.info(f"[{self.name}] üì¢ EVENT EMITTED: vulnerability_detected (XSS)")
```

**Locations to Add**:
1. `_ladder_ui_attacks()` - After line 182 (XSS finding)
2. `_ladder_sqli()` - After line 145 (SQLi finding)

**Time Estimate**: 15 minutes

---

### Step 3: Remove Polling (Final Migration)

**File**: `bugtrace/agents/exploit.py:132-238`

**Current**: Full polling loop (lines 161-231)

**Replace With**:
```python
async def run_loop(self):
    """Event-driven run loop - no polling."""
    dashboard.log(f"[{self.name}] Event-Driven Mode Active", "INFO")
    logger.info(f"[{self.name}] Listening for events...")
    
    while self.running:
        # Only monitor pause state
        await self.check_pause()
        
        # Heartbeat every 30 seconds
        if datetime.now().second % 30 == 0:
            dashboard.update_task(self.name, status="Listening for events...")
        
        # Small sleep to prevent CPU spin
        await asyncio.sleep(1)
    
    logger.info(f"[{self.name}] Event loop stopped")
```

**‚ö†Ô∏è IMPORTANT**: Do this LAST, after confirming events work!

**Time Estimate**: 10 minutes

---

## TESTING STRATEGY

### Phase 1: Test with Dual Mode (Polling + Events)

1. **Current State**: Both polling and events active
2. **Test**: Run scan and verify logs show:
   - "EVENT RECEIVED: new_input_discovered"
   - Successful testing of inputs
3. **Look For**: Duplicate testing (same input tested twice)

### Phase 2: Disable Polling

1. **After**: Events confirmed working
2. **Replace**: run_loop() with minimal version (Step 3 above)
3. **Test**: Full scan, ensure all inputs still tested

### Phase 3: E2E Validation

```bash
# Run full scan
python -m bugtrace scan http://ginandjuice.shop --max-depth 1

# Verify in logs:
grep "EVENT RECEIVED" logs/execution_*.log
# Should see multiple occurrences

# Verify latency
# Time between "new_input_discovered" and "Testing:" should be < 500ms
```

---

## ESTIMATED COMPLETION TIME

| Step | Time | Difficulty |
|------|------|-----------|
| 1. Implement handle_new_input() | 30 min | Medium |
| 2. Add emit() calls | 15 min | Easy |
| 3. Test dual mode | 15 min | Easy |
| 4. Remove polling | 10 min | Easy |
| 5. Final E2E test | 20 min | Medium |
| **TOTAL** | **90 min** | **Medium** |

---

## SUCCESS CRITERIA

- [ ] `handle_new_input()` fully implemented
- [ ] Events emitted for XSS and SQLi findings
- [ ] Dual mode tested (no crashes)
- [ ] Polling removed successfully
- [ ] E2E scan finds same vulnerabilities as before
- [ ] Latency < 500ms (verified in logs)
- [ ] No duplicate testing of inputs

---

## ROLLBACK PLAN

If events cause issues:

1. **Revert run_loop()**: Put back original polling code
2. **Keep event subscriptions**: They won't hurt if not used
3. **Debug**: Check Event Bus stats: `event_bus.get_stats()`

---

## REFERENCE CODE

**Original Polling Logic**: Lines 42-115 (backed up in this guide)

**Event Emission Example**:
```python
await self.event_bus.emit("vulnerability_detected", {
    "finding_id": "...",
    "type": "XSS|SQLi|...",
    "url": "...",
    "payload": "...",
    "confidence": 0.0-1.0,
    "detected_by": self.name,
    "timestamp": datetime.now().isoformat()
})
```

---

## NEXT STEPS AFTER COMPLETION

After ExploitAgent migration is complete and tested:

1. **PASO 5**: Migrate SkepticalAgent (similar pattern)
2. **PASO 6**: Update ReconAgent to emit events
3. **PASO 7**: Integration testing

---

**Created**: 2026-01-01 21:42  
**Status**: Skeleton Ready for Implementation  
**Estimated Completion**: 1-2 hours of focused work
