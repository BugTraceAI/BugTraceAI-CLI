{
    "system_name": "BugtraceAI-CLI Phoenix Edition",
    "version": "1.2.0",
    "last_updated": "2026-01-01",
    "description": "Autonomous Multi-Agent Web Security Testing Framework",
    "architectural_style": "Event-Driven Multi-Agent System with Shared Memory",
    "documentation": "See .ai-context/ for detailed architecture, features, and integration specs",
    "metadata": {
        "total_python_files": 60,
        "total_lines_of_code": 2435,
        "agents_count": 3,
        "external_tools": 3,
        "llm_providers": 1
    },
    "layers": {
        "orchestration": {
            "description": "System-level coordination and lifecycle management",
            "components": [
                "team_orchestrator",
                "conductor",
                "boot_sequence"
            ]
        },
        "agents": {
            "description": "Autonomous specialized agents with distinct roles",
            "components": [
                "recon_agent",
                "exploit_agent",
                "skeptical_agent"
            ]
        },
        "intelligence": {
            "description": "AI/LLM integration and decision-making",
            "components": [
                "llm_client",
                "mutation_engine",
                "adaptive_conductor"
            ]
        },
        "tools": {
            "description": "Automation and exploitation capabilities",
            "components": [
                "browser_manager",
                "visual_crawler",
                "external_tool_manager",
                "manipulator_orchestrator",
                "detector_suite"
            ]
        },
        "persistence": {
            "description": "State management and knowledge retention",
            "components": [
                "memory_manager",
                "state_manager",
                "database"
            ]
        },
        "presentation": {
            "description": "User interface and reporting",
            "components": [
                "dashboard",
                "report_generator"
            ]
        }
    },
    "nodes": [
        {
            "id": "cli_entry",
            "type": "entry_point",
            "file": "bugtrace/__main__.py",
            "lines": 71,
            "label": "CLI Entry Point",
            "framework": "typer",
            "responsibilities": [
                "Parse CLI arguments",
                "Override settings from flags",
                "Run boot sequence",
                "Initialize TeamOrchestrator",
                "Handle SIGINT gracefully"
            ],
            "key_flags": [
                "--target (required)",
                "--safe-mode",
                "--resume",
                "--verbose",
                "--auth user:pass",
                "--max-depth",
                "--max-urls"
            ]
        },
        {
            "id": "boot_sequence",
            "type": "infrastructure",
            "file": "bugtrace/core/boot.py",
            "label": "Boot Sequence & Health Checks",
            "responsibilities": [
                "Validate environment variables (OPENROUTER_API_KEY)",
                "Check network connectivity (ping 8.8.8.8)",
                "Verify LLM model availability",
                "Check Playwright browser binaries",
                "Display Rich TUI status"
            ],
            "outputs": "Boolean (success/failure)"
        },
        {
            "id": "team_orchestrator",
            "type": "orchestrator",
            "file": "bugtrace/core/team.py",
            "lines": 219,
            "label": "TeamOrchestrator (Master Coordinator)",
            "pattern": "Concurrent Agent Manager",
            "responsibilities": [
                "Initialize StateManager (resume support)",
                "Start BrowserManager (Playwright)",
                "Verify LLM connectivity",
                "Launch Rich Dashboard",
                "Spawn all agents concurrently",
                "Handle SIGINT for graceful shutdown",
                "Generate final HTML report",
                "Persist state for resumption"
            ],
            "lifecycle": [
                "init ‚Üí browser.start() ‚Üí llm.verify() ‚Üí dashboard.launch()",
                "spawn agents ‚Üí asyncio.gather([agent.start() for agent in agents])",
                "on completion ‚Üí generate_report() ‚Üí browser.stop() ‚Üí state.save()"
            ],
            "current_issues": [
                "No dynamic agent spawning",
                "Fixed 3 agents (not scalable)",
                "No agent restart on crash"
            ]
        },
        {
            "id": "conductor",
            "type": "orchestrator",
            "file": "bugtrace/core/conductor.py",
            "lines": 73,
            "label": "Conductor (Protocol Manager)",
            "pattern": "Single Source of Truth (SSoT)",
            "responsibilities": [
                "Load protocol/*.md files",
                "Cache protocol content in memory",
                "Generate system prompts for agents",
                "Self-heal missing protocol files"
            ],
            "protocol_files": {
                "context.md": "Mission, behavior rules, security guidelines",
                "tech-stack.md": "Technology stack documentation"
            },
            "singleton": true,
            "current_issues": [
                "Static protocols (no runtime adaptation)",
                "No session-specific customization",
                "No learning from previous scans"
            ]
        },
        {
            "id": "recon_agent",
            "type": "agent",
            "file": "bugtrace/agents/recon.py",
            "lines": 111,
            "label": "ReconAgent (Discovery & Attack Surface Mapping)",
            "role": "Reconnaissance",
            "specialization": "Attack surface identification",
            "execution_phases": [
                {
                    "phase": 0,
                    "name": "Visual Deep Analysis",
                    "actions": [
                        "Capture landing page screenshot via browser_manager",
                        "Send screenshot to LLM vision model",
                        "Extract tech stack, CMS, potential admin paths"
                    ],
                    "tools": [
                        "browser_manager",
                        "llm_client.analyze_visual"
                    ]
                },
                {
                    "phase": 1,
                    "name": "Visual Crawl",
                    "actions": [
                        "Playwright-based crawling (handles SPA/JS)",
                        "Extract all <a> hrefs",
                        "Extract all <input>, <textarea>, <select> elements",
                        "Store URLs and inputs in memory_manager"
                    ],
                    "tools": [
                        "visual_crawler"
                    ],
                    "config": {
                        "max_pages": "settings.MAX_URLS (default: 25)",
                        "max_depth": "settings.MAX_DEPTH (default: 2)"
                    }
                },
                {
                    "phase": 2,
                    "name": "Contextual Path Discovery",
                    "actions": [
                        "Generate standard critical paths (/robots.txt, /.env, /admin)",
                        "LLM predicts framework-specific paths based on Phase 0 analysis",
                        "Add predicted paths to memory for verification"
                    ],
                    "tools": [
                        "llm_client.generate"
                    ],
                    "example_predictions": [
                        "WordPress ‚Üí /wp-admin, /wp-json/wp/v2/users",
                        "Django ‚Üí /admin, /__debug__/",
                        "Laravel ‚Üí /telescope, /horizon"
                    ]
                },
                {
                    "phase": 3,
                    "name": "External Deep Scan",
                    "actions": [
                        "Get session cookies from browser_manager",
                        "Run GoSpider with session context",
                        "Run Nuclei with session context",
                        "Ingest findings into memory_manager"
                    ],
                    "tools": [
                        "external_tools.run_gospider",
                        "external_tools.run_nuclei"
                    ]
                },
                {
                    "phase": 4,
                    "name": "Continuous Monitoring",
                    "actions": [
                        "Enter idle loop",
                        "Check pause_event",
                        "Sleep 5 seconds and repeat"
                    ],
                    "current_issues": [
                        "No dynamic re-crawling",
                        "No response to ExploitAgent discoveries"
                    ]
                }
            ],
            "dependencies": {
                "direct_imports": [
                    "browser_manager (singleton)",
                    "visual_crawler (singleton)",
                    "memory_manager (singleton)",
                    "external_tools (singleton)",
                    "llm_client (singleton)"
                ],
                "coupling_level": "HIGH (5 direct dependencies)"
            },
            "communication": {
                "writes_to_memory": [
                    "URL nodes",
                    "Input nodes"
                ],
                "reads_from_memory": [],
                "events_published": "NONE (polling architecture)",
                "events_subscribed": "NONE"
            }
        },
        {
            "id": "exploit_agent",
            "type": "agent",
            "file": "bugtrace/agents/exploit.py",
            "lines": 203,
            "label": "ExploitAgent (Vulnerability Verification & Exploitation)",
            "role": "Offensive Testing",
            "specialization": "Exploit development and validation",
            "pattern": "Ladder Logic (Light ‚Üí Heavy)",
            "execution_loop": [
                {
                    "step": "Poll Memory",
                    "action": "memory_manager.get_attack_surface('Input')",
                    "frequency": "Every 10 seconds",
                    "issue": "High latency (5-10s before testing new input)"
                },
                {
                    "step": "WAF Detection",
                    "action": "llm_client.detect_waf(response_text, headers)",
                    "models": "WAF_DETECTION_MODELS"
                },
                {
                    "step": "SQLi Ladder",
                    "substeps": [
                        "Light: Python sqli_detector.detect() - error/boolean/time-based",
                        "Heavy: Docker SQLMap (only if light check is suspicious)"
                    ],
                    "safe_mode": "Skips heavy step if SAFE_MODE=true"
                },
                {
                    "step": "XSS Ladder",
                    "substeps": [
                        "Light: Reflection detection",
                        "Mutation: mutation_engine.mutate_payload() with AI",
                        "Verification: Mark for SkepticalAgent"
                    ]
                },
                {
                    "step": "Infrastructure Ladder",
                    "substeps": [
                        "header_detector.detect() - CRLF, Host poisoning",
                        "proto_detector.detect() - HTTP request smuggling",
                        "xxe_detector.detect() - XML external entities"
                    ]
                }
            ],
            "dependencies": {
                "direct_imports": [
                    "memory_manager",
                    "mutation_engine",
                    "sqli_detector",
                    "csti_detector",
                    "header_detector",
                    "proto_detector",
                    "xxe_detector",
                    "external_tools.run_sqlmap",
                    "browser_manager",
                    "llm_client"
                ],
                "coupling_level": "VERY HIGH (10+ direct dependencies)"
            },
            "communication": {
                "reads_from_memory": [
                    "Input nodes (polling)"
                ],
                "writes_to_memory": [
                    "FindingCandidate nodes with status=FIRED"
                ],
                "events_published": "NONE",
                "events_subscribed": "NONE"
            },
            "current_issues": [
                "Polling every 10s creates latency",
                "No prioritization of high-value inputs",
                "Can't dynamically adjust based on findings"
            ]
        },
        {
            "id": "skeptical_agent",
            "type": "agent",
            "file": "bugtrace/agents/skeptic.py",
            "lines": 135,
            "label": "SkepticalAgent (False Positive Elimination)",
            "role": "Verification",
            "specialization": "Visual XSS verification via AI vision models",
            "philosophy": "Don't trust automatic detections - verify visually",
            "execution_loop": [
                {
                    "step": "Poll Memory",
                    "action": "memory_manager.get_attack_surface('FindingCandidate')",
                    "filter": "status == 'FIRED'",
                    "frequency": "Every 5 seconds"
                },
                {
                    "step": "Optimistic Locking",
                    "action": "Update status to 'VERIFYING' immediately",
                    "purpose": "Prevent duplicate verification by multiple instances"
                },
                {
                    "step": "Visual XSS Verification",
                    "substeps": [
                        "browser_manager.verify_xss(url) ‚Üí triggers alert",
                        "Capture screenshot + console logs",
                        "llm_client.analyze_visual(screenshot, audit_prompt)",
                        "Check AI response for 'VERIFIED' keyword"
                    ],
                    "model": "VISION_MODEL (qwen/qwen-2.5-vl-72b-instruct)"
                },
                {
                    "step": "Validation",
                    "criteria": [
                        "Alert dialog clearly visible in screenshot",
                        "Alert message proves execution on target domain",
                        "No evidence of sandboxing"
                    ],
                    "outputs": [
                        "VERIFIED ‚Üí Add to memory as Finding (CRITICAL)",
                        "POTENTIAL_SANDBOX ‚Üí Log warning",
                        "UNRELIABLE ‚Üí Reject finding"
                    ]
                }
            ],
            "tools": {
                "manipulator_orchestrator": "HTTP mutation campaigns",
                "browser_manager": "Dialog handlers, screenshot capture",
                "llm_client": "Vision model analysis"
            },
            "cost_optimization": "Only runs on XSS findings (not SQLi, etc.)",
            "communication": {
                "reads_from_memory": [
                    "FindingCandidate nodes"
                ],
                "writes_to_memory": [
                    "Finding nodes (verified)",
                    "Status updates"
                ],
                "events_published": "NONE",
                "events_subscribed": "NONE"
            },
            "current_issues": [
                "Polling creates ~5s latency",
                "No real-time notification when ExploitAgent finds candidate",
                "Can't provide feedback to ExploitAgent about payload effectiveness"
            ]
        },
        {
            "id": "llm_client",
            "type": "intelligence",
            "file": "bugtrace/core/llm_client.py",
            "lines": 290,
            "label": "LLM Client (OpenRouter Gateway)",
            "pattern": "Model Shifting for Resilience",
            "api_provider": "OpenRouter (https://openrouter.ai)",
            "capabilities": [
                "Text generation (prompts ‚Üí responses)",
                "Vision analysis (screenshot ‚Üí text analysis)",
                "WAF detection (response analysis)",
                "Credit balance tracking",
                "Audit logging (logs/llm_audit.jsonl)"
            ],
            "model_shifting": {
                "description": "Automatic fallback if primary model fails",
                "sequence": "PRIMARY_MODELS list (config)",
                "triggers": [
                    "HTTP 429 (rate limit)",
                    "HTTP 503 (service unavailable)",
                    "finish_reason == 'content_filter'",
                    "JSON parse errors",
                    "Timeouts"
                ],
                "example": [
                    "google/gemini-2.0-flash-thinking-exp:free",
                    "qwen/qwen-2.5-coder-32b-instruct",
                    "x-ai/grok-code-fast-1"
                ]
            },
            "methods": {
                "generate()": {
                    "purpose": "General text generation",
                    "model": "DEFAULT_MODEL or model_override",
                    "temperature": 0.7,
                    "max_tokens": 1500
                },
                "analyze_visual()": {
                    "purpose": "Screenshot analysis",
                    "model": "VISION_MODEL",
                    "input": "base64 encoded PNG + text prompt",
                    "temperature": 0.3,
                    "max_tokens": 800
                },
                "detect_waf()": {
                    "purpose": "WAF fingerprinting",
                    "model": "WAF_DETECTION_MODELS",
                    "input": "response_text + response_headers"
                },
                "update_balance()": {
                    "purpose": "Credit tracking",
                    "endpoint": "/api/v1/auth/key",
                    "updates": "dashboard.update_balance()"
                }
            },
            "rate_limiting": {
                "semaphore": "MAX_CONCURRENT_REQUESTS (default: 1)",
                "reason": "Prevent OpenRouter rate limit"
            },
            "singleton": true
        },
        {
            "id": "browser_manager",
            "type": "tool",
            "file": "bugtrace/tools/visual/browser.py",
            "lines": 226,
            "label": "Browser Manager (Playwright Wrapper)",
            "pattern": "Singleton with Context Management",
            "technology": "Playwright (async API)",
            "browser": "Chromium",
            "capabilities": [
                "Headless browser automation",
                "Cookie/session management",
                "Screenshot capture",
                "XSS verification (dialog detection)",
                "Session data export (cookies ‚Üí external tools)",
                "Login automation",
                "Context isolation (authenticated vs anonymous)"
            ],
            "lifecycle": [
                "start() ‚Üí Launch Playwright ‚Üí Create browser",
                "get_page(use_auth=bool) ‚Üí Context manager",
                "capture_state(url) ‚Üí Screenshot + HTML",
                "verify_xss(url) ‚Üí Dialog handler + screenshot",
                "stop() ‚Üí Close contexts + browser + playwright"
            ],
            "contexts": {
                "_default_context": "Anonymous, ephemeral",
                "_auth_context": "Authenticated, persistent (post-login)"
            },
            "xss_verification": {
                "dialog_handler": "Detects alert(), prompt(), confirm()",
                "wait_time": "3000ms for JS execution",
                "outputs": "(screenshot_path, console_logs, triggered: bool)"
            },
            "session_export": {
                "get_session_data()": {
                    "returns": "{'cookies': [...], 'headers': {...}}",
                    "used_by": "external_tools (GoSpider, Nuclei, SQLMap)"
                }
            },
            "singleton": true
        },
        {
            "id": "visual_crawler",
            "type": "tool",
            "file": "bugtrace/tools/visual/crawler.py",
            "lines": 151,
            "label": "Visual Crawler (Playwright-based)",
            "algorithm": "BFS with depth limiting",
            "capabilities": [
                "JavaScript rendering (handles SPA)",
                "URL normalization (protocol, port, fragments)",
                "Scope enforcement (same-domain only)",
                "Input extraction (input, textarea, select)",
                "Queue size limiting (prevent explosion)"
            ],
            "spa_support": {
                "wait_until": "domcontentloaded",
                "spa_wait_ms": "settings.SPA_WAIT_MS (default: 1000)"
            },
            "extraction": {
                "urls": "Array.from(document.querySelectorAll('a')).map(a => a.href)",
                "inputs": "querySelectorAll('input, textarea, select') ‚Üí {tag, type, name, id, placeholder, value}"
            },
            "configuration": {
                "max_pages": "settings.MAX_URLS",
                "max_depth": "settings.MAX_DEPTH",
                "max_queue_size": "settings.MAX_QUEUE_SIZE (default: 100)"
            },
            "singleton": true
        },
        {
            "id": "external_tool_manager",
            "type": "tool",
            "file": "bugtrace/tools/external.py",
            "lines": 181,
            "label": "External Tool Manager (Docker Orchestration)",
            "pattern": "Docker Container Executor",
            "supported_tools": [
                {
                    "name": "GoSpider",
                    "image": "trickest/gospider",
                    "purpose": "Deep web crawling",
                    "session_aware": true,
                    "output": "Plain text URLs"
                },
                {
                    "name": "Nuclei",
                    "image": "projectdiscovery/nuclei:latest",
                    "purpose": "Vulnerability scanner (5000+ templates)",
                    "session_aware": true,
                    "output": "JSON Lines"
                },
                {
                    "name": "SQLMap",
                    "image": "googlesky/sqlmap:latest",
                    "purpose": "SQL injection exploitation",
                    "session_aware": true,
                    "output": "Text (regex parsed)"
                }
            ],
            "execution_pattern": {
                "_run_container()": [
                    "Build command: [docker, run, --rm, image] + args",
                    "asyncio.create_subprocess_exec()",
                    "Wait for completion",
                    "Return stdout.decode()"
                ]
            },
            "session_context": {
                "description": "Forwards browser cookies to all tools",
                "format": "Cookie: name1=value1; name2=value2",
                "benefit": "Authenticated scanning (post-login)"
            },
            "safe_mode": {
                "run_sqlmap()": "Skipped if settings.SAFE_MODE=true",
                "run_nuclei()": "Always runs (passive scan)",
                "run_gospider()": "Always runs (passive crawl)"
            },
            "singleton": true
        },
        {
            "id": "mutation_engine",
            "type": "tool",
            "file": "bugtrace/tools/exploitation/mutation.py",
            "lines": 99,
            "label": "Mutation Engine (AI-Powered Payload Evolution)",
            "pattern": "Strategy Shifting",
            "purpose": "WAF bypass via LLM-generated payload mutations",
            "strategies": [
                "Advanced Evasion (Polyglots/Event Handlers)",
                "Contextual Blending (Native JS/HTML)",
                "Encoding/Obfuscation Shift",
                "Minimalist Bypass"
            ],
            "workflow": [
                "Receive original_payload (e.g., <script>alert(1)</script>)",
                "Iterate through strategies",
                "For each: LLM prompt with strategy name",
                "Validate LLM output (_validate_payload)",
                "Return first valid mutation or fallback to original"
            ],
            "validation": {
                "_validate_payload()": {
                    "checks": [
                        "Not conversational text ('here is', 'try this')",
                        "Contains attack characters (<>'\";()${}\\)",
                        "Length > 2"
                    ]
                }
            },
            "example_mutations": [
                "Original: <script>alert(1)</script>",
                "Strategy 1: <svg/onload=eval(atob('YWxlcnQoMSk='))>",
                "Strategy 2: <img src=x onerror=\"al\\x65rt(1)\">",
                "Strategy 3: <iframe src=\"javascript:alert(1)\">"
            ],
            "singleton": true
        },
        {
            "id": "manipulator_orchestrator",
            "type": "tool",
            "file": "bugtrace/tools/manipulator/orchestrator.py",
            "lines": 75,
            "label": "Manipulator Orchestrator (HTTP Mutation Campaign)",
            "components": {
                "RequestController": "HTTP execution + rate limiting",
                "PayloadAgent": "XSS/SQLi payload generation",
                "EncodingAgent": "WAF bypass transformations"
            },
            "workflow": {
                "process_finding()": [
                    "Phase 1: Payload Injection",
                    "async for mutation in payload_agent.generate_mutations()",
                    "If blocked: Phase 2: WAF Bypass",
                    "async for encoded in encoding_agent.generate_mutations()",
                    "Return True on first successful exploitation"
                ]
            },
            "response_analysis": {
                "_try_mutation()": {
                    "checks": [
                        "status in [403, 406] ‚Üí WAF blocked",
                        "'alert(1)' in body ‚Üí XSS reflected",
                        "'root:x:0:0' in body ‚Üí LFI/RCE",
                        "'SQL syntax' in body ‚Üí SQLi error"
                    ]
                }
            },
            "rate_limit": "0.5 requests/second (configurable)"
        },
        {
            "id": "detector_suite",
            "type": "tool",
            "files": [
                "bugtrace/tools/exploitation/sqli.py (177 lines)",
                "bugtrace/tools/exploitation/csti.py (76 lines)",
                "bugtrace/tools/exploitation/xxe.py (85 lines)",
                "bugtrace/tools/exploitation/header_injection.py (124 lines)",
                "bugtrace/tools/exploitation/proto.py (62 lines)"
            ],
            "label": "Python-Native Vulnerability Detectors",
            "detectors": {
                "sqli_detector": {
                    "techniques": [
                        "Error-based (MySQL, PostgreSQL, MSSQL, Oracle regex)",
                        "Boolean-based (true/false differential)",
                        "Time-based (SLEEP, WAITFOR DELAY)",
                        "Union-based (column count enumeration)"
                    ],
                    "output": "{'suspicious': bool, 'confirmed': bool, 'confidence': float}"
                },
                "csti_detector": {
                    "templates": [
                        "Jinja2: {{7*7}} ‚Üí '49'",
                        "Twig: {{_self.env.display()}}",
                        "Angular: {{constructor.constructor('alert(1)')()}}"
                    ]
                },
                "xxe_detector": {
                    "payloads": [
                        "File disclosure: <!ENTITY xxe SYSTEM \"file:///etc/passwd\">",
                        "SSRF: <!ENTITY xxe SYSTEM \"http://169.254.169.254/...\">",
                        "DoS: Billion Laughs attack"
                    ]
                },
                "header_injection_detector": {
                    "attacks": [
                        "CRLF: %0d%0aX-Injected: true",
                        "Host poisoning: Host: evil.com"
                    ]
                },
                "proto_detector": {
                    "techniques": [
                        "CL.TE: Content-Length vs Transfer-Encoding",
                        "TE.CL: Transfer-Encoding vs Content-Length"
                    ]
                }
            }
        },
        {
            "id": "memory_manager",
            "type": "persistence",
            "file": "bugtrace/memory/manager.py",
            "lines": 224,
            "label": "Memory Manager (Knowledge Graph + Vector DB)",
            "pattern": "Dual Storage Architecture",
            "storage": {
                "knowledge_graph": {
                    "library": "NetworkX",
                    "type": "DiGraph (directed)",
                    "persistence": "data/memory_graph.gml",
                    "nodes": "URL, Input, Finding, FindingCandidate, Agent",
                    "edges": "contains, vulnerable_to, tested_by"
                },
                "vector_store": {
                    "library": "LanceDB",
                    "embeddings": "sentence-transformers (all-MiniLM-L6-v2, 384-dim)",
                    "schema": "{id, type, label, properties, text, vector}",
                    "table": "memory"
                }
            },
            "operations": {
                "add_node()": {
                    "steps": [
                        "Add to NetworkX graph",
                        "Generate embedding from text",
                        "Add to LanceDB table",
                        "Persist graph to disk"
                    ],
                    "atomic": true
                },
                "add_edge()": "Relationship in graph only",
                "get_attack_surface()": "Filter nodes by type",
                "vector_search()": "Semantic similarity search (top-k)"
            },
            "deduplication": "Node IDs prevent duplicates (type:label)",
            "singleton": true
        },
        {
            "id": "state_manager",
            "type": "persistence",
            "file": "bugtrace/core/state.py",
            "label": "State Manager (Session Persistence)",
            "purpose": "Enable resume functionality (--resume flag)",
            "state_schema": {
                "target": "string",
                "scan_id": "uuid",
                "visited_urls": "list[str]",
                "findings": "list[dict]",
                "agent_states": "dict"
            },
            "operations": {
                "save()": "Write state to JSON file",
                "load()": "Read state from JSON file",
                "restore()": "Replay state to memory_manager"
            },
            "file_path": "data/state/{scan_id}.json"
        },
        {
            "id": "dashboard",
            "type": "presentation",
            "file": "bugtrace/core/ui.py",
            "label": "Rich Dashboard (TUI)",
            "framework": "rich (Python)",
            "layout": {
                "header": "Target, Balance, Session Cost",
                "metrics": "CPU/RAM usage bars (psutil)",
                "payloads": "Last 5 payload tests",
                "logs": "Last 4 log lines",
                "findings": "Last 5 discoveries",
                "footer": "Controls (Pause, Quit, Help)"
            },
            "integration": {
                "logging_sink": "Intercepts loguru logs ‚Üí dashboard.log()",
                "refresh_rate": "2 updates/second (Live.refresh_per_second=2)"
            },
            "methods": {
                "log(message, level)": "Add log entry",
                "add_finding(title, desc, severity)": "Add finding to list",
                "update_task(task_id, name, status)": "Update agent status",
                "update_balance(amount)": "Update LLM credit balance"
            },
            "singleton": true
        },
        {
            "id": "report_generator",
            "type": "presentation",
            "file": "bugtrace/reporting/generator.py",
            "lines": 49,
            "label": "HTML Report Generator",
            "template_engine": "Jinja2",
            "template": "bugtrace/reporting/templates/report.html",
            "sections": [
                "Executive Summary (AI-generated)",
                "Scan Metadata (target, date, duration)",
                "Statistics Dashboard (critical/high/medium counts)",
                "Findings Table (severity, type, URL, proof)",
                "Visual Evidence (embedded screenshots)",
                "Recommendations (AI-generated)"
            ],
            "ai_summary": {
                "prompt": "Generate professional executive summary for scan",
                "model": "DEFAULT_MODEL",
                "module": "ReportWriter"
            },
            "output_path": "reports/report_{target}_{timestamp}/"
        },
        {
            "id": "config_manager",
            "type": "infrastructure",
            "file": "bugtrace/core/config.py",
            "lines": 180,
            "label": "Configuration Manager (Pydantic Settings)",
            "pattern": "Multi-Source Configuration",
            "sources": [
                "1. Default values (hardcoded)",
                "2. .env file",
                "3. bugtraceaicli.conf (INI)",
                "4. Environment variables",
                "5. CLI flags (highest priority)"
            ],
            "sections": {
                "CORE": [
                    "DEBUG",
                    "SAFE_MODE"
                ],
                "SCAN": [
                    "MAX_DEPTH",
                    "MAX_URLS"
                ],
                "LLM_MODELS": [
                    "DEFAULT_MODEL",
                    "PRIMARY_MODELS",
                    "VISION_MODEL",
                    "WAF_DETECTION_MODELS"
                ],
                "BROWSER": [
                    "HEADLESS"
                ],
                "BROWSER_ADVANCED": [
                    "USER_AGENT",
                    "VIEWPORT_WIDTH",
                    "VIEWPORT_HEIGHT",
                    "TIMEOUT_MS"
                ],
                "CRAWLER": [
                    "SPA_WAIT_MS",
                    "MAX_QUEUE_SIZE"
                ]
            },
            "singleton": true
        }
    ],
    "edges": [
        {
            "source": "cli_entry",
            "target": "boot_sequence",
            "interaction": "Runs health checks before orchestration",
            "type": "sequential",
            "blocking": true
        },
        {
            "source": "cli_entry",
            "target": "team_orchestrator",
            "interaction": "Initializes if boot succeeds",
            "type": "sequential",
            "blocking": true
        },
        {
            "source": "team_orchestrator",
            "target": "browser_manager",
            "interaction": "Calls start() during initialization",
            "type": "initialization"
        },
        {
            "source": "team_orchestrator",
            "target": "llm_client",
            "interaction": "Calls verify_connectivity() + update_balance()",
            "type": "initialization"
        },
        {
            "source": "team_orchestrator",
            "target": "dashboard",
            "interaction": "Launches Rich Live dashboard",
            "type": "initialization"
        },
        {
            "source": "team_orchestrator",
            "target": "recon_agent",
            "interaction": "Spawns via asyncio.gather()",
            "type": "concurrent",
            "lifecycle": "start() ‚Üí run_loop()"
        },
        {
            "source": "team_orchestrator",
            "target": "exploit_agent",
            "interaction": "Spawns via asyncio.gather()",
            "type": "concurrent",
            "lifecycle": "start() ‚Üí run_loop()"
        },
        {
            "source": "team_orchestrator",
            "target": "skeptical_agent",
            "interaction": "Spawns via asyncio.gather()",
            "type": "concurrent",
            "lifecycle": "start() ‚Üí run_loop()"
        },
        {
            "source": "team_orchestrator",
            "target": "report_generator",
            "interaction": "Calls generate() after scan completion",
            "type": "sequential"
        },
        {
            "source": "conductor",
            "target": "recon_agent",
            "interaction": "Injects system_prompt via BaseAgent.__init__()",
            "type": "initialization"
        },
        {
            "source": "conductor",
            "target": "exploit_agent",
            "interaction": "Injects system_prompt via BaseAgent.__init__()",
            "type": "initialization"
        },
        {
            "source": "conductor",
            "target": "skeptical_agent",
            "interaction": "Injects system_prompt via BaseAgent.__init__()",
            "type": "initialization"
        },
        {
            "source": "recon_agent",
            "target": "browser_manager",
            "interaction": "capture_state(url) for screenshots",
            "type": "direct_call",
            "frequency": "Once at Phase 0"
        },
        {
            "source": "recon_agent",
            "target": "llm_client",
            "interaction": "analyze_visual(screenshot) for tech stack",
            "type": "direct_call",
            "frequency": "Once at Phase 0"
        },
        {
            "source": "recon_agent",
            "target": "visual_crawler",
            "interaction": "crawl(target) for URL/input discovery",
            "type": "direct_call",
            "frequency": "Once at Phase 1"
        },
        {
            "source": "recon_agent",
            "target": "llm_client",
            "interaction": "generate() for path prediction",
            "type": "direct_call",
            "frequency": "Once at Phase 2"
        },
        {
            "source": "recon_agent",
            "target": "external_tool_manager",
            "interaction": "run_gospider() + run_nuclei()",
            "type": "direct_call",
            "frequency": "Once at Phase 3"
        },
        {
            "source": "recon_agent",
            "target": "memory_manager",
            "interaction": "store_crawler_findings() - writes URLs and Inputs",
            "type": "write",
            "frequency": "After each phase",
            "data": "URL nodes, Input nodes"
        },
        {
            "source": "exploit_agent",
            "target": "memory_manager",
            "interaction": "get_attack_surface('Input') - POLLING",
            "type": "read (polling)",
            "frequency": "Every 10 seconds",
            "issue": "High latency, CPU waste"
        },
        {
            "source": "exploit_agent",
            "target": "llm_client",
            "interaction": "detect_waf() for WAF fingerprinting",
            "type": "direct_call"
        },
        {
            "source": "exploit_agent",
            "target": "detector_suite",
            "interaction": "sqli_detector.detect(), csti_detector.detect(), etc.",
            "type": "direct_call",
            "pattern": "Ladder Logic (light checks)"
        },
        {
            "source": "exploit_agent",
            "target": "mutation_engine",
            "interaction": "mutate_payload() for WAF bypass",
            "type": "direct_call"
        },
        {
            "source": "exploit_agent",
            "target": "external_tool_manager",
            "interaction": "run_sqlmap() if light SQLi check is suspicious",
            "type": "direct_call",
            "pattern": "Ladder Logic (heavy check)",
            "safe_mode": "Skipped if SAFE_MODE=true"
        },
        {
            "source": "exploit_agent",
            "target": "browser_manager",
            "interaction": "get_session_data() for cookies",
            "type": "direct_call"
        },
        {
            "source": "exploit_agent",
            "target": "memory_manager",
            "interaction": "add_node('FindingCandidate') with status=FIRED",
            "type": "write",
            "data": "FindingCandidate nodes for SkepticalAgent"
        },
        {
            "source": "skeptical_agent",
            "target": "memory_manager",
            "interaction": "get_attack_surface('FindingCandidate') - POLLING",
            "type": "read (polling)",
            "frequency": "Every 5 seconds",
            "filter": "status == 'FIRED'",
            "issue": "High latency"
        },
        {
            "source": "skeptical_agent",
            "target": "browser_manager",
            "interaction": "verify_xss() for visual confirmation",
            "type": "direct_call"
        },
        {
            "source": "skeptical_agent",
            "target": "llm_client",
            "interaction": "analyze_visual() for screenshot audit",
            "type": "direct_call",
            "model": "VISION_MODEL"
        },
        {
            "source": "skeptical_agent",
            "target": "manipulator_orchestrator",
            "interaction": "process_finding() for HTTP mutation",
            "type": "direct_call"
        },
        {
            "source": "skeptical_agent",
            "target": "memory_manager",
            "interaction": "add_node('Finding', verified=True) + screenshot_path",
            "type": "write",
            "data": "Verified Finding nodes (CRITICAL severity)"
        },
        {
            "source": "browser_manager",
            "target": "external_tool_manager",
            "interaction": "Exports cookies via get_session_data()",
            "type": "data_flow",
            "receivers": [
                "GoSpider",
                "Nuclei",
                "SQLMap"
            ]
        },
        {
            "source": "visual_crawler",
            "target": "browser_manager",
            "interaction": "Uses get_page() context manager",
            "type": "dependency"
        },
        {
            "source": "mutation_engine",
            "target": "llm_client",
            "interaction": "generate() for payload mutations",
            "type": "direct_call",
            "strategies": 4
        },
        {
            "source": "manipulator_orchestrator",
            "target": "browser_manager",
            "interaction": "HTTP request execution (RequestController)",
            "type": "indirect"
        },
        {
            "source": "all_agents",
            "target": "dashboard",
            "interaction": "Logging via loguru ‚Üí dashboard_sink",
            "type": "logging"
        },
        {
            "source": "report_generator",
            "target": "memory_manager",
            "interaction": "get_attack_surface('Finding') for report data",
            "type": "read"
        },
        {
            "source": "report_generator",
            "target": "llm_client",
            "interaction": "generate() for AI summary and recommendations",
            "type": "direct_call"
        }
    ],
    "communication_patterns": {
        "agent_to_agent": {
            "current": "Indirect via memory_manager (polling)",
            "latency": "5-10 seconds",
            "issues": [
                "No real-time notification",
                "CPU waste (constant polling)",
                "Doesn't scale with more agents"
            ],
            "proposed_improvement": "Event Bus (pub/sub pattern)"
        },
        "agent_to_tool": {
            "current": "Direct imports and calls",
            "coupling": "HIGH (tight coupling)",
            "issues": [
                "Hard to mock for testing",
                "Can't swap implementations",
                "Agent knows tool internals"
            ],
            "proposed_improvement": "Dependency Injection via interfaces"
        }
    },
    "architectural_issues": {
        "polling_overhead": {
            "description": "ExploitAgent and SkepticalAgent poll memory every 5-10s",
            "impact": "Latency + CPU waste",
            "solution": "Event Bus",
            "status": "üü° IN PROGRESS - Event Bus implemented, agent migration pending"
        },
        "tight_coupling": {
            "description": "Agents import tools directly (browser_manager, llm_client, etc.)",
            "impact": "Hard to test, can't swap implementations",
            "solution": "Dependency Injection",
            "status": "‚è≥ PLANNED - Phase 2"
        },
        "no_feedback_loop": {
            "description": "ExploitAgent discoveries don't inform ReconAgent priorities",
            "impact": "Inefficient scanning (no dynamic adaptation)",
            "solution": "Bidirectional event communication",
            "status": "‚è≥ PLANNED - Via Event Bus (Phase 1 completion)"
        },
        "fixed_agent_count": {
            "description": "Always spawns exactly 3 agents",
            "impact": "Can't scale or specialize dynamically",
            "solution": "Dynamic agent spawning",
            "status": "‚è≥ PLANNED - Phase 4"
        },
        "static_protocols": {
            "description": "Conductor loads static protocol files at startup",
            "impact": "No session-specific adaptation",
            "solution": "Adaptive Conductor with LLM-generated protocols",
            "status": "‚è≥ PLANNED - Phase 3"
        }
    },
    "performance_metrics": {
        "lines_of_code": 2435,
        "agents": 3,
        "tools": 11,
        "avg_scan_duration": "2-5 minutes (depends on target)",
        "memory_usage": "~200MB (includes browser)",
        "docker_containers": "0-3 (GoSpider, Nuclei, SQLMap on-demand)",
        "llm_api_calls": "50-150 per scan",
        "avg_session_cost": "$0.50-$2.00 (depends on models)"
    },
    "future_roadmap": {
        "phase_1_event_bus": {
            "description": "Replace polling with pub/sub events",
            "files": [
                "bugtrace/core/event_bus.py",
                "bugtrace/agents/*.py"
            ],
            "impact": "100x faster agent communication (10s ‚Üí 50ms)",
            "effort": "1 week",
            "status": "üü° IN PROGRESS - 57% complete (4/7 steps)",
            "started": "2026-01-01 21:23",
            "completed_steps": [
                "Event Bus core (193 lines, 9/9 tests passing)",
                "BaseAgent integration hooks",
                "TeamOrchestrator integration",
                "ExploitAgent migration (320 lines, event-driven)"
            ],
            "pending_steps": [
                "SkepticalAgent migration",
                "ReconAgent event emission",
                "Integration testing & validation"
            ],
            "last_updated": "2026-01-01 21:47"
        },
        "phase_2_dependency_injection": {
            "description": "Introduce interfaces for tools",
            "files": [
                "bugtrace/core/interfaces.py"
            ],
            "impact": "Testability + flexibility",
            "effort": "1 week"
        },
        "phase_3_adaptive_conductor": {
            "description": "LLM-generated session-specific protocols",
            "files": [
                "bugtrace/core/conductor_v2.py",
                "bugtrace/persistence/target_intelligence.py"
            ],
            "impact": "30% better finding rate on repeated targets",
            "effort": "2 weeks"
        },
        "phase_4_dynamic_spawning": {
            "description": "Spawn specialist agents on-demand",
            "files": [
                "bugtrace/core/team.py"
            ],
            "impact": "Scalability + resource efficiency",
            "effort": "1 week"
        }
    }
}