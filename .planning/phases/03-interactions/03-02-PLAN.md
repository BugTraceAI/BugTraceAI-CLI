---
phase: 03-interactions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bugtrace/core/ui/tui/widgets/log_inspector.py
  - bugtrace/core/ui/tui/widgets/command_input.py
  - bugtrace/core/ui/tui/styles.tcss
autonomous: true

must_haves:
  truths:
    - "LogInspector widget exists with filterable log view"
    - "CommandInput widget exists with command submission"
    - "Log filtering works in real-time"
    - "Commands like /stop, /help are recognized"
  artifacts:
    - path: "bugtrace/core/ui/tui/widgets/log_inspector.py"
      provides: "Filterable log viewer"
      contains: "class LogInspector"
    - path: "bugtrace/core/ui/tui/widgets/command_input.py"
      provides: "Command input bar"
      contains: "class CommandInput"
---

<objective>
Create the LogInspector and CommandInput widgets for log filtering and ChatOps-style commands.

Purpose: Users can filter logs in real-time and issue commands like /stop, /help, /filter.

Output: Two new widgets ready for integration in Plan 03-03.
</objective>

<execution_context>
@/home/albert/.claude/get-shit-done/workflows/execute-plan.md
@/home/albert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@bugtrace/core/ui/tui/widgets/log_panel.py (existing log widget for reference)
@bugtrace/core/ui/tui/styles.tcss
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LogInspector widget</name>
  <files>bugtrace/core/ui/tui/widgets/log_inspector.py</files>
  <action>
Create `widgets/log_inspector.py` with filterable log viewing:

```python
"""Filterable log inspector widget."""

from textual.widgets import Static, Input, RichLog
from textual.containers import Vertical
from textual.reactive import reactive
from textual.app import ComposeResult
from rich.text import Text
from typing import List, Tuple
from collections import deque


class LogInspector(Vertical):
    """Filterable log viewer with search input."""

    # Current filter text
    filter_text: reactive[str] = reactive("")

    # Store all logs for filtering
    _all_logs: List[Tuple[str, str]] = []  # (level, message)

    # Max logs to keep in memory
    MAX_LOGS = 2000

    CSS = """
    LogInspector {
        height: 100%;
    }

    #log-filter {
        dock: top;
        height: 3;
        margin: 0 0 1 0;
    }

    #log-view {
        height: 1fr;
        border: solid $secondary;
        scrollbar-gutter: stable;
    }
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._all_logs = []

    def compose(self) -> ComposeResult:
        """Compose the log inspector layout."""
        yield Input(
            placeholder="Filter logs (e.g., ERROR, XSS, Agent)...",
            id="log-filter"
        )
        yield RichLog(
            id="log-view",
            highlight=True,
            markup=True,
            max_lines=1000,
            wrap=True,
        )

    def on_input_changed(self, event: Input.Changed) -> None:
        """Handle filter input changes."""
        if event.input.id == "log-filter":
            self.filter_text = event.value
            self._apply_filter()

    def log(self, message: str, level: str = "INFO") -> None:
        """Add a log entry."""
        # Store for filtering
        self._all_logs.append((level, message))

        # Trim if too many
        if len(self._all_logs) > self.MAX_LOGS:
            self._all_logs = self._all_logs[-self.MAX_LOGS:]

        # Only display if matches filter
        if self._matches_filter(level, message):
            self._write_log(level, message)

    def _matches_filter(self, level: str, message: str) -> bool:
        """Check if log entry matches current filter."""
        if not self.filter_text:
            return True

        filter_lower = self.filter_text.lower()
        return (
            filter_lower in level.lower() or
            filter_lower in message.lower()
        )

    def _write_log(self, level: str, message: str) -> None:
        """Write a log entry to the RichLog widget."""
        try:
            log_widget = self.query_one("#log-view", RichLog)

            # Color by level
            level_colors = {
                "ERROR": "bold red",
                "WARNING": "yellow",
                "INFO": "blue",
                "DEBUG": "dim white",
                "SUCCESS": "green",
            }
            color = level_colors.get(level.upper(), "white")

            # Format with Rich markup
            formatted = Text()
            formatted.append(f"[{level.upper():7}] ", style=color)
            formatted.append(message)

            log_widget.write(formatted)
        except Exception:
            pass  # Widget may not be mounted

    def _apply_filter(self) -> None:
        """Re-apply filter to all logs."""
        try:
            log_widget = self.query_one("#log-view", RichLog)
            log_widget.clear()

            # Re-write matching logs
            for level, message in self._all_logs:
                if self._matches_filter(level, message):
                    self._write_log(level, message)
        except Exception:
            pass  # Widget may not be mounted

    def clear(self) -> None:
        """Clear all logs."""
        self._all_logs.clear()
        try:
            log_widget = self.query_one("#log-view", RichLog)
            log_widget.clear()
        except Exception:
            pass
```

Key features:
- Filter input at top with placeholder hint
- RichLog widget with syntax highlighting
- Real-time filtering as user types
- Stores all logs for re-filtering
- Level-based coloring (ERROR=red, WARNING=yellow, etc.)
- Max 2000 logs in memory to prevent OOM
  </action>
  <verify>
Run `python -c "from bugtrace.core.ui.tui.widgets.log_inspector import LogInspector; print('OK')"` - should print OK.
  </verify>
  <done>
LogInspector widget created with filterable RichLog and level-based coloring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CommandInput widget</name>
  <files>bugtrace/core/ui/tui/widgets/command_input.py</files>
  <action>
Create `widgets/command_input.py` for ChatOps-style commands:

```python
"""Command input bar for ChatOps-style control."""

from textual.widgets import Input
from textual.message import Message
from textual.binding import Binding
from typing import List


class CommandInput(Input):
    """Command bar for ChatOps-style control."""

    class CommandSubmitted(Message):
        """Message sent when a command is submitted."""

        def __init__(self, command: str) -> None:
            super().__init__()
            self.command = command

    # Command history
    _history: List[str] = []
    _history_index: int = -1
    MAX_HISTORY = 50

    BINDINGS = [
        Binding("up", "history_prev", "Previous command", show=False),
        Binding("down", "history_next", "Next command", show=False),
    ]

    CSS = """
    CommandInput {
        dock: bottom;
        height: 3;
        margin: 0 1;
        border: solid $primary;
    }

    CommandInput:focus {
        border: solid $accent;
    }
    """

    def __init__(self, **kwargs):
        super().__init__(
            placeholder="Enter command (e.g., /stop, /help, /filter xss)...",
            **kwargs
        )
        self._history = []
        self._history_index = -1

    def on_input_submitted(self, event: Input.Submitted) -> None:
        """Handle command submission."""
        command = event.value.strip()
        if command:
            # Add to history
            self._history.append(command)
            if len(self._history) > self.MAX_HISTORY:
                self._history = self._history[-self.MAX_HISTORY:]
            self._history_index = -1

            # Post message for app to handle
            self.post_message(self.CommandSubmitted(command))

            # Clear input
            self.value = ""

    def action_history_prev(self) -> None:
        """Navigate to previous command in history."""
        if not self._history:
            return

        if self._history_index == -1:
            self._history_index = len(self._history) - 1
        elif self._history_index > 0:
            self._history_index -= 1

        self.value = self._history[self._history_index]
        self.cursor_position = len(self.value)

    def action_history_next(self) -> None:
        """Navigate to next command in history."""
        if not self._history or self._history_index == -1:
            return

        if self._history_index < len(self._history) - 1:
            self._history_index += 1
            self.value = self._history[self._history_index]
        else:
            self._history_index = -1
            self.value = ""

        self.cursor_position = len(self.value)


# Supported commands documentation
COMMANDS = {
    "/stop": "Stop the current scan",
    "/pause": "Pause the scan",
    "/resume": "Resume a paused scan",
    "/help": "Show available commands",
    "/filter <text>": "Filter logs and findings by text",
    "/show <agent>": "Show only specified agent's activity",
    "/clear": "Clear the log view",
    "/export": "Export findings to file",
}
```

Key features:
- Extends Input with command submission
- Posts CommandSubmitted message for app handling
- Up/Down arrow keys for command history
- Max 50 commands in history
- Placeholder with usage hint
- COMMANDS dict documents available commands
  </action>
  <verify>
Run `python -c "from bugtrace.core.ui.tui.widgets.command_input import CommandInput, COMMANDS; print(len(COMMANDS), 'commands defined')"` - should print number of commands.
  </verify>
  <done>
CommandInput widget created with history navigation and CommandSubmitted message.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add log inspector and command input styles</name>
  <files>bugtrace/core/ui/tui/styles.tcss</files>
  <action>
Append log inspector and command input styles to `styles.tcss`:

```css
/* ===== Log Inspector ===== */
#log-inspector {
    height: 100%;
}

#log-inspector #log-filter {
    background: $surface;
}

#log-inspector #log-view {
    background: $surface-darken-1;
}

/* ===== Command Input ===== */
#command-input {
    background: $surface;
}

#command-input:focus {
    background: $surface-lighten-1;
}
```

These complement the inline CSS in widgets for consistent theming.
  </action>
  <verify>
Run `grep -c "log-inspector" bugtrace/core/ui/tui/styles.tcss` - should return at least 1.
  </verify>
  <done>
Global styles added for LogInspector and CommandInput.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update widgets __init__.py exports</name>
  <files>bugtrace/core/ui/tui/widgets/__init__.py</files>
  <action>
Add new widgets to the widgets package exports:

```python
# Add to existing imports
from .log_inspector import LogInspector
from .command_input import CommandInput, COMMANDS

# Add to __all__ if it exists
```

Read the current __init__.py first, then append the new exports.
  </action>
  <verify>
Run `python -c "from bugtrace.core.ui.tui.widgets import LogInspector, CommandInput; print('OK')"` - should print OK.
  </verify>
  <done>
Widgets package updated to export LogInspector and CommandInput.
  </done>
</task>

</tasks>

<verification>
1. **Static verification:**
   - LogInspector class exists in widgets/log_inspector.py
   - CommandInput class exists in widgets/command_input.py
   - Both export from widgets/__init__.py
   - Styles added to styles.tcss

2. **Runtime verification:**
   - Both modules import without errors
   - CommandInput.CommandSubmitted message type exists
   - COMMANDS dict is populated

3. **Integration ready:**
   - LogInspector.log(message, level) works
   - LogInspector._apply_filter() filters in real-time
   - CommandInput posts CommandSubmitted on Enter
   - History navigation with Up/Down arrows
</verification>

<success_criteria>
- [ ] LogInspector widget with filter input and RichLog
- [ ] Real-time filtering as user types
- [ ] Level-based log coloring
- [ ] CommandInput widget with message posting
- [ ] Command history with Up/Down navigation
- [ ] COMMANDS dict documents available commands
- [ ] All files import without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-interactions/03-02-SUMMARY.md`
</output>
