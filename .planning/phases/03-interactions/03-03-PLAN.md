---
phase: 03-interactions
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - bugtrace/core/ui/tui/screens/main.py
  - bugtrace/core/ui/tui/app.py
  - bugtrace/core/ui/tui/styles.tcss
autonomous: true

must_haves:
  truths:
    - "MainScreen layout includes FindingsTable, LogInspector, CommandInput"
    - "Row selection opens FindingDetailsModal"
    - "Command handler processes /stop, /help, /filter"
    - "Keyboard shortcuts work (f, l, :, q)"
    - "No UI lag with 100+ findings"
  artifacts:
    - path: "bugtrace/core/ui/tui/screens/main.py"
      provides: "Updated layout with new widgets"
      contains: "FindingsTable"
    - path: "bugtrace/core/ui/tui/app.py"
      provides: "Command handler and keyboard bindings"
      contains: "on_command_input_command_submitted"
  key_links:
    - from: "DataTable.RowSelected"
      to: "FindingDetailsModal"
      via: "push_screen()"
      pattern: "push_screen.*FindingDetailsModal"
    - from: "CommandInput.CommandSubmitted"
      to: "App command handler"
      via: "on_command_input_command_submitted"
      pattern: "def on_command_input_command_submitted"
---

<objective>
Integrate FindingsTable, LogInspector, and CommandInput into MainScreen, wire up event handlers, and add keyboard shortcuts.

Purpose: Complete the high-fidelity interaction features by connecting all pieces together.

Output: Fully interactive TUI with modals, filtering, and commands.
</objective>

<execution_context>
@/home/albert/.claude/get-shit-done/workflows/execute-plan.md
@/home/albert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@bugtrace/core/ui/tui/screens/main.py
@bugtrace/core/ui/tui/app.py
@bugtrace/core/ui/tui/styles.tcss
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update MainScreen layout with new widgets</name>
  <files>bugtrace/core/ui/tui/screens/main.py</files>
  <action>
Read the current main.py and update compose() to include the new widgets.

**Add imports:**
```python
from bugtrace.core.ui.tui.widgets.findings_table import FindingsTable
from bugtrace.core.ui.tui.widgets.log_inspector import LogInspector
from bugtrace.core.ui.tui.widgets.command_input import CommandInput
```

**Update compose() method:**

Replace or enhance the existing layout to include:
1. FindingsTable in a prominent position (middle or bottom section)
2. LogInspector replacing or alongside LogPanel
3. CommandInput at the very bottom (docked)

The layout should be:
```
┌─────────────────────────────────────────────────────┐
│ Header                                              │
├─────────────────────────────────────────────────────┤
│ Pipeline Status                                     │
├────────────────────────┬────────────────────────────┤
│ Activity │ Metrics     │ Agent Swarm                │
├────────────────────────┴────────────────────────────┤
│ Findings Table                                      │
├────────────────────────┬────────────────────────────┤
│ Payload Feed           │ Log Inspector              │
├────────────────────────┴────────────────────────────┤
│ Command Input                                       │
├─────────────────────────────────────────────────────┤
│ Footer                                              │
└─────────────────────────────────────────────────────┘
```

Example compose():
```python
def compose(self) -> ComposeResult:
    yield Header(show_clock=True)

    with Container(id="main-content"):
        # Top: Pipeline status
        yield PipelineStatus(id="pipeline")

        # Row 1: Activity + Metrics | Swarm
        with Horizontal(classes="dashboard-row"):
            with Vertical(classes="left-panel"):
                yield ActivityGraph(id="activity")
                yield SystemMetrics(id="metrics")
            yield AgentSwarm(id="swarm")

        # Row 2: Findings Table (full width)
        yield FindingsTable(id="findings-table")

        # Row 3: Payload Feed | Log Inspector
        with Horizontal(classes="dashboard-row"):
            yield PayloadFeed(id="payload-feed")
            yield LogInspector(id="log-inspector")

    yield CommandInput(id="command-input")
    yield Footer()
```

Preserve existing widget IDs for backward compatibility with message handlers.
  </action>
  <verify>
Run `grep -c "FindingsTable" bugtrace/core/ui/tui/screens/main.py` - should return at least 1.
Run `grep -c "LogInspector" bugtrace/core/ui/tui/screens/main.py` - should return at least 1.
Run `grep -c "CommandInput" bugtrace/core/ui/tui/screens/main.py` - should return at least 1.
  </verify>
  <done>
MainScreen layout updated with FindingsTable, LogInspector, and CommandInput.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire table row selection to modal</name>
  <files>bugtrace/core/ui/tui/app.py</files>
  <action>
Add DataTable row selection handler to app.py:

**Add imports:**
```python
from textual.widgets import DataTable
from bugtrace.core.ui.tui.widgets.findings_table import FindingsTable
from bugtrace.core.ui.tui.screens.modals import FindingDetailsModal
```

**Add handler method:**
```python
def on_data_table_row_selected(self, event: DataTable.RowSelected) -> None:
    """Open finding details when row selected in findings table."""
    # Only handle findings table
    if not isinstance(event.data_table, FindingsTable):
        return

    table = event.data_table
    finding = table.get_finding(event.row_key.value)

    if finding:
        self.push_screen(FindingDetailsModal(finding))
```

This hooks into Textual's built-in DataTable.RowSelected message.
  </action>
  <verify>
Run `grep -c "on_data_table_row_selected" bugtrace/core/ui/tui/app.py` - should return 1.
Run `grep -c "FindingDetailsModal" bugtrace/core/ui/tui/app.py` - should return at least 1.
  </verify>
  <done>
Row selection handler wired to open FindingDetailsModal.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement command handler</name>
  <files>bugtrace/core/ui/tui/app.py</files>
  <action>
Add command handler for CommandInput messages:

**Add import:**
```python
from bugtrace.core.ui.tui.widgets.command_input import CommandInput, COMMANDS
from bugtrace.core.ui.tui.widgets.log_inspector import LogInspector
```

**Add handler method:**
```python
def on_command_input_command_submitted(
    self, message: CommandInput.CommandSubmitted
) -> None:
    """Handle commands from the command input bar."""
    cmd = message.command.strip()
    cmd_lower = cmd.lower()

    # Parse command and arguments
    parts = cmd.split(maxsplit=1)
    command = parts[0].lower()
    args = parts[1] if len(parts) > 1 else ""

    if command in ("/stop", "stop"):
        self._handle_stop()

    elif command in ("/pause", "pause"):
        self._handle_pause()

    elif command in ("/resume", "resume"):
        self._handle_resume()

    elif command in ("/help", "help", "?"):
        self._show_help()

    elif command in ("/filter", "filter"):
        self._apply_filter(args)

    elif command in ("/show", "show"):
        self._show_agent(args)

    elif command in ("/clear", "clear"):
        self._clear_logs()

    elif command in ("/export", "export"):
        self._export_findings()

    else:
        self.notify(f"Unknown command: {command}", severity="warning")
        self.notify("Type /help for available commands")

def _handle_stop(self) -> None:
    """Stop the current scan."""
    if hasattr(self, '_scan_worker') and self._scan_worker:
        self._scan_worker.cancel()
        self.notify("Scan stopped")
    else:
        self.notify("No scan running", severity="warning")

def _handle_pause(self) -> None:
    """Pause the scan (placeholder)."""
    self.notify("Pause not implemented yet", severity="warning")

def _handle_resume(self) -> None:
    """Resume the scan (placeholder)."""
    self.notify("Resume not implemented yet", severity="warning")

def _show_help(self) -> None:
    """Show help for available commands."""
    help_lines = ["Available commands:"]
    for cmd, desc in COMMANDS.items():
        help_lines.append(f"  {cmd}: {desc}")

    # Write to log inspector if available
    try:
        inspector = self.query_one("#log-inspector", LogInspector)
        for line in help_lines:
            inspector.log(line, level="INFO")
    except Exception:
        pass

    self.notify("Help written to log panel")

def _apply_filter(self, filter_text: str) -> None:
    """Apply filter to log inspector."""
    try:
        inspector = self.query_one("#log-inspector", LogInspector)
        filter_input = inspector.query_one("#log-filter")
        filter_input.value = filter_text
        self.notify(f"Filter applied: {filter_text}")
    except Exception as e:
        self.notify(f"Filter failed: {e}", severity="error")

def _show_agent(self, agent_name: str) -> None:
    """Filter to show only specific agent."""
    if not agent_name:
        self.notify("Usage: /show <agent-name>", severity="warning")
        return
    self._apply_filter(agent_name)

def _clear_logs(self) -> None:
    """Clear the log inspector."""
    try:
        inspector = self.query_one("#log-inspector", LogInspector)
        inspector.clear()
        self.notify("Logs cleared")
    except Exception:
        pass

def _export_findings(self) -> None:
    """Export findings to file (placeholder)."""
    self.notify("Export not implemented yet", severity="warning")
```
  </action>
  <verify>
Run `grep -c "on_command_input_command_submitted" bugtrace/core/ui/tui/app.py` - should return 1.
Run `grep -c "_handle_stop" bugtrace/core/ui/tui/app.py` - should return at least 1.
  </verify>
  <done>
Command handler implemented with /stop, /help, /filter, /clear commands.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add keyboard shortcuts</name>
  <files>bugtrace/core/ui/tui/app.py</files>
  <action>
Add keyboard bindings to BugTraceApp class:

**Update BINDINGS:**
```python
BINDINGS = [
    # Existing bindings...
    Binding("q", "quit", "Quit", priority=True),
    Binding("f", "focus_findings", "Findings"),
    Binding("l", "focus_logs", "Logs"),
    Binding(":", "focus_command", "Command"),
    Binding("?", "show_help", "Help"),
    Binding("escape", "unfocus", "Unfocus", show=False),
]
```

**Add action methods:**
```python
def action_focus_findings(self) -> None:
    """Focus the findings table."""
    try:
        self.query_one("#findings-table").focus()
    except Exception:
        pass

def action_focus_logs(self) -> None:
    """Focus the log inspector."""
    try:
        self.query_one("#log-inspector").focus()
    except Exception:
        pass

def action_focus_command(self) -> None:
    """Focus the command input."""
    try:
        self.query_one("#command-input").focus()
    except Exception:
        pass

def action_show_help(self) -> None:
    """Show help via command handler."""
    self._show_help()

def action_unfocus(self) -> None:
    """Remove focus from current widget."""
    self.screen.set_focus(None)
```
  </action>
  <verify>
Run `grep -c "action_focus_findings" bugtrace/core/ui/tui/app.py` - should return 1.
Run `grep -c "focus_command" bugtrace/core/ui/tui/app.py` - should return at least 1.
  </verify>
  <done>
Keyboard shortcuts added for findings (f), logs (l), command (:), help (?), quit (q).
  </done>
</task>

<task type="auto">
  <name>Task 5: Update NewFinding handler for FindingsTable</name>
  <files>bugtrace/core/ui/tui/app.py</files>
  <action>
Update the on_new_finding handler to also add findings to FindingsTable:

Find the existing `on_new_finding` method and update it:

```python
def on_new_finding(self, message: NewFinding) -> None:
    """Handle new vulnerability finding."""
    self._total_findings += 1

    # Update FindingsSummary (existing widget)
    try:
        findings = self.query_one("#findings", FindingsSummary)
        findings.add_finding(
            finding_type=message.finding_type,
            details=message.details,
            severity=message.severity.upper(),
        )
    except Exception:
        pass

    # Also add to FindingsTable (new widget)
    try:
        table = self.query_one("#findings-table", FindingsTable)
        table.add_finding(
            finding_type=message.finding_type,
            details=message.details,
            severity=message.severity,
            param=message.param,
            payload=message.payload,
        )
    except Exception:
        pass

    # Show notification
    severity_colors = {
        "critical": "red",
        "high": "orange",
        "medium": "yellow",
        "low": "blue",
        "info": "dim",
    }
    color = severity_colors.get(message.severity.lower(), "white")
    self.notify(
        f"[{color}][{message.severity.upper()}][/{color}] {message.finding_type}",
        severity="warning" if message.severity.lower() in ("critical", "high") else "information",
    )
```

Add import for FindingsTable if not already present.
  </action>
  <verify>
Run `grep -c "findings-table" bugtrace/core/ui/tui/app.py` - should return at least 2 (handler + focus).
  </verify>
  <done>
NewFinding handler updated to populate both FindingsSummary and FindingsTable.
  </done>
</task>

<task type="auto">
  <name>Task 6: Update LogEntry handler for LogInspector</name>
  <files>bugtrace/core/ui/tui/app.py</files>
  <action>
Update the on_log_entry handler to also add logs to LogInspector:

Find the existing `on_log_entry` method and update it:

```python
def on_log_entry(self, message: LogEntry) -> None:
    """Handle log entry."""
    # Update LogPanel (existing widget)
    try:
        logs = self.query_one("#logs", LogPanel)
        logs.log(message.message, level=message.level)
    except Exception:
        pass

    # Also add to LogInspector (new widget)
    try:
        inspector = self.query_one("#log-inspector", LogInspector)
        inspector.log(message.message, level=message.level)
    except Exception:
        pass
```

Add import for LogInspector if not already present.
  </action>
  <verify>
Run `grep -c "log-inspector" bugtrace/core/ui/tui/app.py` - should return at least 2.
  </verify>
  <done>
LogEntry handler updated to populate both LogPanel and LogInspector.
  </done>
</task>

<task type="auto">
  <name>Task 7: Update styles for new layout</name>
  <files>bugtrace/core/ui/tui/styles.tcss</files>
  <action>
Add/update styles for the new layout structure:

```css
/* ===== Dashboard Layout ===== */
.dashboard-row {
    height: auto;
    min-height: 8;
}

.left-panel {
    width: 1fr;
    max-width: 40;
}

/* ===== Findings Table Section ===== */
#findings-table {
    height: 12;
    min-height: 8;
    margin: 1 0;
}

/* ===== Bottom Row ===== */
#payload-feed {
    width: 1fr;
}

#log-inspector {
    width: 1fr;
}

/* ===== Responsive: Small terminals ===== */
@media (width < 100) {
    .dashboard-row {
        layout: vertical;
    }

    .left-panel {
        max-width: 100%;
    }
}
```
  </action>
  <verify>
Run `grep -c "dashboard-row" bugtrace/core/ui/tui/styles.tcss` - should return at least 1.
  </verify>
  <done>
Styles updated for new dashboard layout with responsive breakpoints.
  </done>
</task>

<task type="auto">
  <name>Task 8: Verify full integration</name>
  <files>bugtrace/core/ui/tui/app.py</files>
  <action>
Run syntax check and import verification:

```bash
python -m py_compile bugtrace/core/ui/tui/app.py
python -m py_compile bugtrace/core/ui/tui/screens/main.py
python -c "from bugtrace.core.ui.tui.app import BugTraceApp; print('App imports OK')"
```

Verify all pieces connect:
1. MainScreen composes new widgets
2. App handles DataTable.RowSelected → opens modal
3. App handles CommandInput.CommandSubmitted → executes commands
4. Keyboard shortcuts focus appropriate widgets
5. Message handlers populate new widgets

If any errors, fix them.
  </action>
  <verify>
`python -c "from bugtrace.core.ui.tui.app import BugTraceApp; print('OK')"` prints OK.
`python -c "from bugtrace.core.ui.tui.screens.main import MainScreen; print('OK')"` prints OK.
  </verify>
  <done>
Full integration verified - all imports work, no syntax errors.
  </done>
</task>

</tasks>

<verification>
1. **Static verification:**
   - MainScreen includes FindingsTable, LogInspector, CommandInput
   - App has on_data_table_row_selected handler
   - App has on_command_input_command_submitted handler
   - Keyboard bindings defined (f, l, :, ?, q)

2. **Runtime verification:**
   - `bugtrace tui --demo` launches without errors
   - New widgets visible in layout

3. **Integration verification (manual):**
   - Press Enter on finding row → modal opens
   - Escape → modal closes
   - Type in filter input → logs filter
   - Type /help in command input → help shows
   - Press f → findings table focused
   - Press : → command input focused
</verification>

<success_criteria>
- [ ] Layout includes all new widgets
- [ ] Row selection opens modal
- [ ] Commands work (/stop, /help, /filter)
- [ ] Keyboard shortcuts work
- [ ] No import or syntax errors
- [ ] Demo mode still works
</success_criteria>

<output>
After completion, create `.planning/phases/03-interactions/03-03-SUMMARY.md`
</output>
