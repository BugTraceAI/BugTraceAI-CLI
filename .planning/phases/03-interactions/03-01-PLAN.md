# Plan 03-01: High-Fidelity Interactions

## Frontmatter

```yaml
wave: 1
depends_on: []
files_modified:
  - bugtrace/core/ui/tui/widgets/findings_table.py
  - bugtrace/core/ui/tui/screens/modals/__init__.py
  - bugtrace/core/ui/tui/screens/modals/finding_details.py
  - bugtrace/core/ui/tui/widgets/log_inspector.py
  - bugtrace/core/ui/tui/widgets/command_input.py
  - bugtrace/core/ui/tui/screens/main.py
  - bugtrace/core/ui/tui/app.py
  - bugtrace/core/ui/tui/styles.tcss
autonomous: true
```

## Objective

Enable TUI-first features: interactive DataTable for findings, modals, log filtering, and command input.

## Context

- **Source spec:** `.ai-context/planning/TASK_004_INTERACTION.md`
- **Prerequisites:** Phase 1 (foundation) and Phase 2 (widgets + async) complete
- **Target features:**
  - Scrollable, sortable findings table
  - Finding details modal with request/response
  - Filterable log inspector
  - Command input bar (ChatOps)

## Tasks

<task id="1" name="Implement FindingsTable widget">
Create `widgets/findings_table.py`:

```python
from textual.widgets import DataTable
from textual.reactive import reactive

class FindingsTable(DataTable):
    """Interactive findings table with sorting and selection."""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.cursor_type = "row"
        self.zebra_stripes = True

    def on_mount(self):
        self.add_columns("Severity", "Type", "Parameter", "Time", "Status")

    def add_finding(self, finding):
        """Add a finding row with severity-based styling."""
        severity_styles = {
            "CRITICAL": "bold red",
            "HIGH": "red",
            "MEDIUM": "yellow",
            "LOW": "green",
        }
        style = severity_styles.get(finding.severity, "white")
        self.add_row(
            finding.severity,
            finding.finding_type,
            finding.param or "-",
            finding.time,
            finding.status,
            key=finding.id,
        )

    def action_sort_by_severity(self):
        self.sort("Severity", reverse=True)

    def action_sort_by_type(self):
        self.sort("Type")
```

Key features:
- Cursor navigation (up/down arrows)
- Row selection triggers modal
- Sortable columns
- Scrollable (hundreds of findings)
</task>

<task id="2" name="Create modals directory structure">
Create:
```
bugtrace/core/ui/tui/screens/modals/
├── __init__.py
└── finding_details.py
```
</task>

<task id="3" name="Implement FindingDetailsModal" depends_on="2">
Create `screens/modals/finding_details.py`:

```python
from textual.screen import ModalScreen
from textual.widgets import Static, Button, TextArea
from textual.containers import Vertical, Horizontal
from textual.binding import Binding

class FindingDetailsModal(ModalScreen):
    """Modal showing full finding details with request/response."""

    BINDINGS = [
        Binding("escape", "dismiss", "Close"),
        Binding("c", "copy_payload", "Copy Payload"),
    ]

    def __init__(self, finding, **kwargs):
        super().__init__(**kwargs)
        self.finding = finding

    def compose(self) -> ComposeResult:
        with Vertical(id="modal-container"):
            yield Static(f"[bold]{self.finding.finding_type}[/]", id="modal-title")
            yield Static(f"Severity: {self.finding.severity}", classes="modal-field")
            yield Static(f"Parameter: {self.finding.param}", classes="modal-field")

            yield Static("[bold]Payload:[/]", classes="section-header")
            yield TextArea(self.finding.payload, read_only=True, id="payload-area")

            yield Static("[bold]Request:[/]", classes="section-header")
            yield TextArea(self.finding.request or "N/A", read_only=True, id="request-area")

            yield Static("[bold]Response (excerpt):[/]", classes="section-header")
            yield TextArea(self.finding.response_excerpt or "N/A", read_only=True, id="response-area")

            with Horizontal(classes="modal-buttons"):
                yield Button("Copy Payload", id="copy-btn", variant="primary")
                yield Button("Close", id="close-btn")

    def action_dismiss(self):
        self.dismiss()

    def action_copy_payload(self):
        import pyperclip
        pyperclip.copy(self.finding.payload)
        self.notify("Payload copied to clipboard")

    def on_button_pressed(self, event: Button.Pressed):
        if event.button.id == "copy-btn":
            self.action_copy_payload()
        elif event.button.id == "close-btn":
            self.dismiss()
```
</task>

<task id="4" name="Wire table selection to modal" depends_on="1,3">
Update `screens/main.py` or `app.py`:

```python
def on_data_table_row_selected(self, event: DataTable.RowSelected):
    """Open finding details when row selected."""
    table = event.data_table
    if table.id == "findings-table":
        finding = self.get_finding_by_key(event.row_key)
        if finding:
            self.push_screen(FindingDetailsModal(finding))
```

Also add key binding in MainScreen:
```python
BINDINGS = [
    Binding("enter", "select_row", "View Details"),
]
```
</task>

<task id="5" name="Implement LogInspector widget">
Create `widgets/log_inspector.py`:

```python
from textual.widgets import Static, Input, Log
from textual.containers import Vertical
from textual.reactive import reactive

class LogInspector(Vertical):
    """Filterable log viewer."""

    filter_text = reactive("")

    def compose(self) -> ComposeResult:
        yield Input(placeholder="Filter logs (e.g., ERROR, XSS)...", id="log-filter")
        yield Log(id="log-view", highlight=True, max_lines=1000)

    def on_input_changed(self, event: Input.Changed):
        if event.input.id == "log-filter":
            self.filter_text = event.value
            self._apply_filter()

    def add_log(self, level: str, message: str):
        log_widget = self.query_one("#log-view", Log)
        # Color by level
        level_colors = {
            "ERROR": "red",
            "WARNING": "yellow",
            "INFO": "blue",
            "DEBUG": "dim white",
        }
        color = level_colors.get(level, "white")
        formatted = f"[{color}][{level}][/] {message}"
        log_widget.write_line(formatted)

    def _apply_filter(self):
        """Filter displayed logs by text."""
        # Log widget handles this via CSS or we implement virtual list
        pass
```
</task>

<task id="6" name="Implement CommandInput widget">
Create `widgets/command_input.py`:

```python
from textual.widgets import Input
from textual.message import Message

class CommandInput(Input):
    """Command bar for ChatOps-style control."""

    class CommandSubmitted(Message):
        def __init__(self, command: str):
            super().__init__()
            self.command = command

    def __init__(self, **kwargs):
        super().__init__(
            placeholder="Enter command or ask BugTrace...",
            **kwargs
        )

    def on_input_submitted(self, event: Input.Submitted):
        command = event.value.strip()
        if command:
            self.post_message(self.CommandSubmitted(command))
            self.value = ""  # Clear input
```
</task>

<task id="7" name="Implement command handler" depends_on="6">
Add command processing to `app.py`:

```python
class BugTraceApp(App):
    def on_command_input_command_submitted(self, message: CommandInput.CommandSubmitted):
        cmd = message.command.lower()

        if cmd == "/stop" or cmd == "stop":
            self._stop_scan()
            self.notify("Scan stopped")

        elif cmd == "/pause" or cmd == "pause":
            self._pause_scan()
            self.notify("Scan paused")

        elif cmd == "/resume" or cmd == "resume":
            self._resume_scan()
            self.notify("Scan resumed")

        elif cmd.startswith("/show "):
            agent = cmd.split(" ", 1)[1]
            self._filter_to_agent(agent)

        elif cmd.startswith("/filter "):
            filter_text = cmd.split(" ", 1)[1]
            self._apply_global_filter(filter_text)

        elif cmd == "/help":
            self._show_help()

        else:
            self.notify(f"Unknown command: {cmd}", severity="warning")

    def _stop_scan(self):
        if self.scan_worker:
            self.scan_worker.cancel()

    def _show_help(self):
        help_text = """
        Commands:
        /stop    - Stop current scan
        /pause   - Pause scan
        /resume  - Resume paused scan
        /show <agent> - Filter to specific agent
        /filter <text> - Filter logs/findings
        /help    - Show this help
        """
        self.notify(help_text)
```
</task>

<task id="8" name="Update MainScreen layout" depends_on="1,5,6">
Update `screens/main.py` to include new widgets:

```python
class MainScreen(Screen):
    def compose(self) -> ComposeResult:
        yield Header(show_clock=True)
        yield Container(
            # Top section: Pipeline + Metrics
            PipelineStatus(id="pipeline"),
            Container(
                ActivityGraph(id="activity"),
                SystemMetrics(id="metrics"),
                classes="metrics-row"
            ),
            # Middle section: Swarm + Findings Table
            Container(
                AgentSwarm(id="swarm"),
                FindingsTable(id="findings-table"),
                classes="middle-row"
            ),
            # Bottom section: Payload Feed + Log Inspector
            Container(
                PayloadFeed(id="payload-feed"),
                LogInspector(id="log-inspector"),
                classes="bottom-row"
            ),
            id="main-content"
        )
        yield CommandInput(id="command-input")
        yield Footer()
```
</task>

<task id="9" name="Add modal styles" depends_on="3">
Update `styles.tcss` for modal:

```css
#modal-container {
    width: 80%;
    height: 80%;
    background: $surface;
    border: thick $primary;
    padding: 1;
}

.modal-field {
    margin-bottom: 1;
}

.section-header {
    margin-top: 1;
    color: $primary;
}

#payload-area, #request-area, #response-area {
    height: 6;
    border: solid $secondary;
}

.modal-buttons {
    margin-top: 1;
    align: center middle;
}

/* Command input at bottom */
#command-input {
    dock: bottom;
    margin: 0 1;
}
```
</task>

<task id="10" name="Add keyboard navigation" depends_on="8">
Update key bindings across the app:

```python
# In app.py
BINDINGS = [
    Binding("q", "quit", "Quit"),
    Binding("f", "focus_findings", "Findings"),
    Binding("l", "focus_logs", "Logs"),
    Binding(":", "focus_command", "Command"),
    Binding("?", "show_help", "Help"),
    Binding("escape", "unfocus", "Unfocus"),
]

def action_focus_findings(self):
    self.query_one("#findings-table").focus()

def action_focus_logs(self):
    self.query_one("#log-inspector").focus()

def action_focus_command(self):
    self.query_one("#command-input").focus()
```
</task>

<task id="11" name="Test full interaction flow">
Verify:

1. Launch app with `--tui`
2. Start scan (if target provided)
3. Findings populate in table as they're discovered
4. Click/Enter on finding opens modal
5. Escape closes modal
6. Filter logs by typing in filter input
7. Enter commands in command bar
8. /stop actually stops the scan
9. All keyboard shortcuts work
10. Hundreds of findings don't crash or lag
</task>

## Verification Criteria

- [ ] FindingsTable is sortable and scrollable
- [ ] Row selection opens FindingDetailsModal
- [ ] Escape closes modal
- [ ] Copy button works (pyperclip)
- [ ] LogInspector filters in real-time
- [ ] CommandInput handles /stop, /pause, /help
- [ ] Keyboard shortcuts work (f, l, :, ?, q)
- [ ] No UI lag with 100+ findings
- [ ] Experience feels "native" and polished

## Must-Haves (Goal-Backward)

For production readiness:
1. **Responsive layout** - Works on 80x24 minimum terminal
2. **Graceful degradation** - Missing pyperclip doesn't crash
3. **Accessibility** - Full keyboard navigation
4. **Performance** - Virtual scrolling for large datasets
