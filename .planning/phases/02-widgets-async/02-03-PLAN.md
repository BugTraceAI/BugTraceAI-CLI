---
phase: 02-widgets-async
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - bugtrace/core/ui/tui/app.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Real-time scan updates flow from pipeline to widgets"
    - "AgentSwarm widget shows actual agent status during scan"
    - "PipelineStatus widget shows current phase and progress"
    - "FindingsSummary widget displays vulnerabilities as they are found"
    - "PayloadFeed widget shows payloads being tested"
    - "LogPanel widget displays log messages from pipeline"
    - "SystemMetrics widget shows CPU/RAM from MetricsUpdate"
  artifacts:
    - path: "bugtrace/core/ui/tui/app.py"
      provides: "Wired message handlers"
      contains: "query_one.*swarm.*AgentSwarm"
  key_links:
    - from: "BugTraceApp.on_agent_update"
      to: "AgentSwarm.update_agent"
      via: "query_one('#swarm')"
      pattern: "swarm\\.update_agent"
    - from: "BugTraceApp.on_pipeline_progress"
      to: "PipelineStatus reactive attrs"
      via: "query_one('#pipeline')"
      pattern: "pipeline\\.phase.*="
    - from: "BugTraceApp.on_new_finding"
      to: "FindingsSummary.add_finding"
      via: "query_one('#findings')"
      pattern: "findings\\.add_finding"
    - from: "BugTraceApp.on_payload_tested"
      to: "PayloadFeed.add_payload"
      via: "query_one('#payload-feed')"
      pattern: "feed\\.add_payload"
    - from: "BugTraceApp.on_log_entry"
      to: "LogPanel.log"
      via: "query_one('#logs')"
      pattern: "logs\\.log"
    - from: "BugTraceApp.on_metrics_update"
      to: "SystemMetrics/ActivityGraph"
      via: "query_one('#metrics'), query_one('#activity')"
      pattern: "metrics\\.(cpu_usage|ram_usage)"
---

<objective>
Wire message handlers in app.py to call actual widget update methods.

Purpose: Close verification gap where message handlers only log but do not update widgets. Without this wiring, real scan data never reaches the UI - only demo mode works.

Output: app.py with all 6 message handlers calling their corresponding widget methods via query_one().
</objective>

<execution_context>
@/home/albert/.claude/get-shit-done/workflows/execute-plan.md
@/home/albert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-widgets-async/02-VERIFICATION.md

@bugtrace/core/ui/tui/app.py
@bugtrace/core/ui/tui/messages.py
@bugtrace/core/ui/tui/screens/main.py
@bugtrace/core/ui/tui/widgets/swarm.py
@bugtrace/core/ui/tui/widgets/pipeline.py
@bugtrace/core/ui/tui/widgets/findings.py
@bugtrace/core/ui/tui/widgets/payload_feed.py
@bugtrace/core/ui/tui/widgets/log_panel.py
@bugtrace/core/ui/tui/widgets/metrics.py
@bugtrace/core/ui/tui/widgets/activity.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire all message handlers to widgets</name>
  <files>bugtrace/core/ui/tui/app.py</files>
  <action>
Update the message handler section of BugTraceApp (lines 247-340) to call widget methods.

**Add imports at top of file (after existing imports):**
```python
from bugtrace.core.ui.tui.widgets.swarm import AgentSwarm
from bugtrace.core.ui.tui.widgets.pipeline import PipelineStatus
from bugtrace.core.ui.tui.widgets.findings import FindingsSummary
from bugtrace.core.ui.tui.widgets.payload_feed import PayloadFeed
from bugtrace.core.ui.tui.widgets.log_panel import LogPanel
from bugtrace.core.ui.tui.widgets.metrics import SystemMetrics
from bugtrace.core.ui.tui.widgets.activity import ActivityGraph
```

**Replace each message handler with wired version:**

1. **on_agent_update** (replace lines 251-260):
```python
def on_agent_update(self, message: AgentUpdate) -> None:
    """Handle agent status update."""
    try:
        swarm = self.query_one("#swarm", AgentSwarm)
        swarm.update_agent(
            message.agent_name,
            message.status,
            queue=message.queue,
            processed=message.processed,
            vulns=message.vulns,
        )
    except Exception:
        pass  # Widget may not be mounted yet
```

2. **on_pipeline_progress** (replace lines 262-270):
```python
def on_pipeline_progress(self, message: PipelineProgress) -> None:
    """Handle pipeline progress update."""
    try:
        pipeline = self.query_one("#pipeline", PipelineStatus)
        pipeline.phase = message.phase
        pipeline.progress = message.progress * 100  # Convert 0-1 to 0-100
        if message.status_msg:
            pipeline.status_msg = message.status_msg
    except Exception:
        pass  # Widget may not be mounted yet

    # Also update app subtitle for visibility
    self.sub_title = f"{message.phase}: {int(message.progress * 100)}%"
```

3. **on_new_finding** (replace lines 272-291):
```python
def on_new_finding(self, message: NewFinding) -> None:
    """Handle new vulnerability finding."""
    self._total_findings += 1

    try:
        findings = self.query_one("#findings", FindingsSummary)
        findings.add_finding(
            finding_type=message.finding_type,
            details=message.details,
            severity=message.severity.upper(),
        )
    except Exception:
        pass  # Widget may not be mounted yet

    # Show notification for findings
    severity_colors = {
        "critical": "red",
        "high": "orange",
        "medium": "yellow",
        "low": "blue",
        "info": "dim",
    }
    color = severity_colors.get(message.severity.lower(), "white")
    self.notify(
        f"[{color}][{message.severity.upper()}][/{color}] {message.finding_type}",
        severity="warning" if message.severity.lower() in ("critical", "high") else "information",
    )
```

4. **on_payload_tested** (replace lines 293-303):
```python
def on_payload_tested(self, message: PayloadTested) -> None:
    """Handle payload tested notification."""
    try:
        feed = self.query_one("#payload-feed", PayloadFeed)
        # Map result to status
        status_map = {"success": "confirmed", "fail": "failed", "blocked": "blocked"}
        status = status_map.get(message.result, "testing")
        feed.add_payload(
            payload=message.payload,
            agent=message.agent,
            status=status,
        )
    except Exception:
        pass  # Widget may not be mounted yet
```

5. **on_log_entry** (replace lines 305-319):
```python
def on_log_entry(self, message: LogEntry) -> None:
    """Handle log entry."""
    try:
        logs = self.query_one("#logs", LogPanel)
        logs.log(message.message, level=message.level)
    except Exception:
        pass  # Widget may not be mounted yet
```

6. **on_metrics_update** (replace lines 321-327):
```python
def on_metrics_update(self, message: MetricsUpdate) -> None:
    """Handle system metrics update."""
    try:
        metrics = self.query_one("#metrics", SystemMetrics)
        metrics.cpu_usage = message.cpu
        metrics.ram_usage = message.ram
    except Exception:
        pass  # Widget may not be mounted yet

    try:
        activity = self.query_one("#activity", ActivityGraph)
        activity.req_rate = message.req_rate
        if message.req_rate > activity.peak_rate:
            activity.peak_rate = message.req_rate
    except Exception:
        pass  # Widget may not be mounted yet
```

**Remove all "Widget integration comes in Plan 02-01" comments.**

**Why try/except:** Widgets may not be mounted if we're on LoaderScreen or during screen transitions. Silent failure is appropriate here.
  </action>
  <verify>
Run `grep -n "query_one.*#swarm" bugtrace/core/ui/tui/app.py` - should find the line.
Run `grep -n "query_one.*#pipeline" bugtrace/core/ui/tui/app.py` - should find the line.
Run `grep -n "query_one.*#findings" bugtrace/core/ui/tui/app.py` - should find the line.
Run `grep -n "query_one.*#payload-feed" bugtrace/core/ui/tui/app.py` - should find the line.
Run `grep -n "query_one.*#logs" bugtrace/core/ui/tui/app.py` - should find the line.
Run `grep -n "query_one.*#metrics" bugtrace/core/ui/tui/app.py` - should find the line.
Run `grep -c "Widget integration comes in Plan" bugtrace/core/ui/tui/app.py` - should return 0 (no stale comments).
  </verify>
  <done>
All 6 message handlers call their respective widget methods via query_one(). No stale "Widget integration comes in Plan" comments remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify app.py syntax and imports</name>
  <files>bugtrace/core/ui/tui/app.py</files>
  <action>
Run Python syntax check on app.py to catch any issues.

Also verify that the app can be instantiated without errors by running:
```bash
python -c "from bugtrace.core.ui.tui.app import BugTraceApp; print('OK')"
```

If any import errors occur, fix them (likely missing widget imports).
  </action>
  <verify>
`python -c "from bugtrace.core.ui.tui.app import BugTraceApp; print('OK')"` prints "OK" without errors.
`python -m py_compile bugtrace/core/ui/tui/app.py` exits with code 0.
  </verify>
  <done>
app.py has valid Python syntax and can be imported without errors.
  </done>
</task>

</tasks>

<verification>
1. **Static verification:**
   - All 6 message handlers contain query_one() calls
   - No "Widget integration comes in Plan" comments remain
   - All required widget imports are present

2. **Runtime verification:**
   - app.py can be imported without errors
   - `bugtrace tui --demo` still works (demo mode unaffected)

3. **Integration verification (manual):**
   - Run `bugtrace tui --target <test-url>` against a real target
   - Observe widgets updating during scan (not just subtitle)
</verification>

<success_criteria>
- All 6 message handlers wire to widgets via query_one()
- app.py compiles and imports without errors
- Demo mode still works as before
- Real scan updates flow to widgets (agent status, findings, logs, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/02-widgets-async/02-03-SUMMARY.md`

Also update `.planning/phases/02-widgets-async/02-VERIFICATION.md`:
- Change `status: gaps_found` to `status: verified`
- Change `score: 5/7` to `score: 7/7`
- Update the two failed truths to `status: verified`
</output>
