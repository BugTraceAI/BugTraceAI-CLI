# Plan 02-01: Widget Migration (Frontend)

## Frontmatter

```yaml
wave: 1
depends_on: []
files_modified:
  - bugtrace/core/ui/tui/widgets/metrics.py
  - bugtrace/core/ui/tui/widgets/pipeline.py
  - bugtrace/core/ui/tui/widgets/activity.py
  - bugtrace/core/ui/tui/widgets/swarm.py
  - bugtrace/core/ui/tui/widgets/payload_feed.py
  - bugtrace/core/ui/tui/widgets/findings.py
  - bugtrace/core/ui/tui/widgets/log_panel.py
  - bugtrace/core/ui/tui/screens/main.py
  - bugtrace/core/ui/tui/styles.tcss
autonomous: true
```

## Objective

Port Rich rendering logic from `ui.py` into reusable Textual widgets with reactive attributes.

## Context

- **Source spec:** `.ai-context/planning/TASK_002_WIDGETS.md`
- **Legacy methods to port:**
  - `_render_phase_pipeline()` (line 498)
  - `_render_activity_graph()` (line 599)
  - `_render_system_metrics()` (line 619)
  - `_render_specialist_swarm()` (line 670)
  - `_render_payload_feed()` (line 732)
  - `_render_findings_summary()` (line 926)
  - `_render_activity_log_panel()` (line 798)

- **Reusable class:** `SparklineBuffer` (line 50-75) - keep as-is, import into widgets

## Tasks

<task id="1" name="Extract SparklineBuffer utility">
Create `bugtrace/core/ui/tui/utils.py`:

1. Copy `SparklineBuffer` class from `ui.py` lines 50-75
2. Keep the `render()` method that returns Rich `Text`
3. This is shared by multiple widgets (activity, metrics)
</task>

<task id="2" name="Implement PipelineStatus widget" depends_on="1">
Create `widgets/pipeline.py`:

```python
from textual.widgets import Static
from textual.reactive import reactive

class PipelineStatus(Static):
    phase = reactive("INITIALIZING")
    progress = reactive(0.0)
    status_msg = reactive("Starting...")

    def render(self):
        # Port logic from _render_phase_pipeline() (line 498-562)
        # Use Rich Panel with progress bar
        pass
```

Key elements from legacy:
- Phase icons: DISCOVERY/ANALYSIS/SPECIALIST/FINAL
- Progress bar with gradient colors
- Status message below
</task>

<task id="3" name="Implement ActivityGraph widget" depends_on="1">
Create `widgets/activity.py`:

```python
class ActivityGraph(Static):
    req_rate = reactive(0.0)

    def on_mount(self):
        self.buffer = SparklineBuffer(60)
        self.set_interval(1.0, self._update)

    def render(self):
        # Port from _render_activity_graph() (line 599-617)
        pass
```

Key elements:
- Sparkline visualization
- Rate display (req/s)
- Peak tracking
</task>

<task id="4" name="Implement SystemMetrics widget" depends_on="1">
Create `widgets/metrics.py`:

```python
class SystemMetrics(Static):
    cpu_usage = reactive(0.0)
    ram_usage = reactive(0.0)
    threads_count = reactive(0)

    def on_mount(self):
        self.cpu_buffer = SparklineBuffer(30)
        self.ram_buffer = SparklineBuffer(30)
        self.set_interval(1.0, self._update_metrics)

    def render(self):
        # Port from _render_system_metrics() (line 619-640)
        pass
```

Key elements:
- CPU/RAM percentage bars
- Sparkline history
- Thread count
- Requires psutil (optional, graceful fallback)
</task>

<task id="5" name="Implement AgentSwarm widget">
Create `widgets/swarm.py`:

```python
class AgentSwarm(Static):
    agents = reactive({})  # Dict[str, Dict] with status, queue, processed, vulns

    def update_agent(self, name: str, status: str, **kwargs):
        # Thread-safe update
        pass

    def render(self):
        # Port from _render_specialist_swarm() (line 670-730)
        pass
```

Key elements from `_render_specialist_swarm()`:
- Agent tiles with status (IDLE/ACTIVE/WAITING/ERROR/DONE)
- Color-coded status
- Queue/processed/vulns counts per agent
- Responsive grid layout
</task>

<task id="6" name="Implement PayloadFeed widget">
Create `widgets/payload_feed.py`:

```python
class PayloadFeed(Static):
    payloads = reactive([])  # Recent payload history
    current_payload = reactive("")

    def render(self):
        # Port from _render_payload_feed() (line 732-796)
        pass
```

Key elements:
- Live feed of tested payloads
- Color by result (success/fail/blocked)
- Truncation for long payloads
- Current payload highlight
</task>

<task id="7" name="Implement FindingsSummary widget">
Create `widgets/findings.py`:

```python
class FindingsSummary(Static):
    findings = reactive([])  # List of (type, details, severity, time, status)

    def render(self):
        # Port from _render_findings_summary() (line 926-955)
        pass
```

Key elements:
- Count by severity (CRITICAL/HIGH/MEDIUM/LOW)
- Recent findings preview
- Click to expand (Phase 3)
</task>

<task id="8" name="Implement LogPanel widget">
Create `widgets/log_panel.py`:

```python
class LogPanel(Static):
    logs = reactive([])  # List of (timestamp, level, message)

    def render(self):
        # Port from _render_activity_log_panel() (line 798-829)
        pass
```

Key elements:
- Color-coded by level (ERROR=red, WARNING=yellow, INFO=blue)
- Timestamp prefix
- Scrollable (via CSS overflow)
</task>

<task id="9" name="Update MainScreen composition" depends_on="2,3,4,5,6,7,8">
Update `screens/main.py` to use real widgets:

```python
from ..widgets.pipeline import PipelineStatus
from ..widgets.activity import ActivityGraph
from ..widgets.metrics import SystemMetrics
from ..widgets.swarm import AgentSwarm
from ..widgets.payload_feed import PayloadFeed
from ..widgets.findings import FindingsSummary
from ..widgets.log_panel import LogPanel

class MainScreen(Screen):
    def compose(self) -> ComposeResult:
        yield Header(show_clock=True)
        yield Container(
            PipelineStatus(id="pipeline"),
            Container(
                ActivityGraph(id="activity"),
                SystemMetrics(id="metrics"),
                classes="metrics-row"
            ),
            Container(
                AgentSwarm(id="swarm"),
                PayloadFeed(id="payload-feed"),
                classes="middle-row"
            ),
            Container(
                FindingsSummary(id="findings"),
                LogPanel(id="logs"),
                classes="bottom-row"
            ),
            id="main-content"
        )
        yield Footer()
```
</task>

<task id="10" name="Update styles.tcss" depends_on="9">
Add widget-specific styles:

1. `.metrics-row` - horizontal split for activity/metrics
2. `.middle-row` - horizontal split for swarm/payload
3. `.bottom-row` - horizontal split for findings/logs
4. Panel borders matching Rich ROUNDED
5. Color variables for severity levels
</task>

<task id="11" name="Add mock data for testing" depends_on="10">
Create test mode in widgets:

1. Each widget has `demo_mode` reactive attribute
2. When `demo_mode=True`, generate random/cycling data
3. Use `set_interval()` to animate mock data
4. This allows visual testing without real scan

Add `--demo` flag to CLI for testing widgets.
</task>

## Verification Criteria

- [ ] All 7 widget files exist in `widgets/`
- [ ] Widgets render Rich Text/Panel objects
- [ ] Visual output matches legacy `ui.py` appearance
- [ ] Widgets resize gracefully with terminal
- [ ] Demo mode works with `--demo` flag
- [ ] No blocking calls in widget code

## Must-Haves (Goal-Backward)

For Phase 3 (Interactions):
1. **Reactive attributes** - All data exposed via `reactive()` for message-driven updates
2. **Widget IDs** - Each widget has unique ID for `query_one()` lookups
3. **Modular composition** - Widgets are self-contained, no cross-dependencies
