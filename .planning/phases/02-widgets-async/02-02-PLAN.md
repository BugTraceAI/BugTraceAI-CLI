# Plan 02-02: Async Engine Wiring (Backend)

## Frontmatter

```yaml
wave: 1
depends_on: []
files_modified:
  - bugtrace/core/ui/tui/workers.py
  - bugtrace/core/ui/tui/messages.py
  - bugtrace/core/ui/tui/app.py
  - bugtrace/core/conductor.py
  - bugtrace/core/ui/tui/screens/main.py
autonomous: true
```

## Objective

Connect the BugTraceAI scanning pipeline to the Textual UI using async Workers and Messages.

## Context

- **Source spec:** `.ai-context/planning/TASK_003_ASYNC_WIRE.md`
- **Current pipeline:** `bugtrace/core/conductor.py` orchestrates phases
- **Current UI coupling:** `ui.py` uses global `dashboard` instance with direct method calls
- **Target:** Event-driven messaging between pipeline and UI

## Tasks

<task id="1" name="Define Message types">
Create `bugtrace/core/ui/tui/messages.py`:

```python
from textual.message import Message
from typing import Any, Dict, Optional

class AgentUpdate(Message):
    """Sent when an agent's status changes."""
    def __init__(self, agent_name: str, status: str, queue: int = 0,
                 processed: int = 0, vulns: int = 0):
        super().__init__()
        self.agent_name = agent_name
        self.status = status
        self.queue = queue
        self.processed = processed
        self.vulns = vulns

class PipelineProgress(Message):
    """Sent when pipeline phase/progress changes."""
    def __init__(self, phase: str, progress: float, status_msg: str = ""):
        super().__init__()
        self.phase = phase
        self.progress = progress
        self.status_msg = status_msg

class NewFinding(Message):
    """Sent when a vulnerability is discovered."""
    def __init__(self, finding_type: str, details: str, severity: str,
                 param: Optional[str] = None, payload: Optional[str] = None):
        super().__init__()
        self.finding_type = finding_type
        self.details = details
        self.severity = severity
        self.param = param
        self.payload = payload

class PayloadTested(Message):
    """Sent when a payload is tested."""
    def __init__(self, payload: str, result: str, agent: str):
        super().__init__()
        self.payload = payload
        self.result = result  # "success", "fail", "blocked"
        self.agent = agent

class LogEntry(Message):
    """Sent for logging."""
    def __init__(self, level: str, message: str):
        super().__init__()
        self.level = level
        self.message = message

class MetricsUpdate(Message):
    """Sent periodically with system/scan metrics."""
    def __init__(self, cpu: float = 0, ram: float = 0, req_rate: float = 0,
                 urls_discovered: int = 0, urls_analyzed: int = 0):
        super().__init__()
        self.cpu = cpu
        self.ram = ram
        self.req_rate = req_rate
        self.urls_discovered = urls_discovered
        self.urls_analyzed = urls_analyzed

class ScanComplete(Message):
    """Sent when the scan finishes."""
    def __init__(self, total_findings: int, duration: float):
        super().__init__()
        self.total_findings = total_findings
        self.duration = duration
```
</task>

<task id="2" name="Create ScanWorker" depends_on="1">
Create `bugtrace/core/ui/tui/workers.py`:

```python
from textual.worker import Worker, WorkerState
from textual import work
from .messages import (AgentUpdate, PipelineProgress, NewFinding,
                       PayloadTested, LogEntry, MetricsUpdate, ScanComplete)

class UICallback:
    """Bridge between pipeline and Textual app via messages."""

    def __init__(self, app):
        self.app = app

    def on_phase_change(self, phase: str, progress: float, status: str):
        self.app.post_message(PipelineProgress(phase, progress, status))

    def on_agent_update(self, agent: str, status: str, **kwargs):
        self.app.post_message(AgentUpdate(agent, status, **kwargs))

    def on_finding(self, finding_type: str, details: str, severity: str, **kwargs):
        self.app.post_message(NewFinding(finding_type, details, severity, **kwargs))

    def on_payload_tested(self, payload: str, result: str, agent: str):
        self.app.post_message(PayloadTested(payload, result, agent))

    def on_log(self, level: str, message: str):
        self.app.post_message(LogEntry(level, message))

    def on_metrics(self, **kwargs):
        self.app.post_message(MetricsUpdate(**kwargs))

    def on_complete(self, total_findings: int, duration: float):
        self.app.post_message(ScanComplete(total_findings, duration))
```

The actual scan execution uses Textual's `@work` decorator in the App class.
</task>

<task id="3" name="Patch conductor for callback injection" depends_on="2">
Modify `bugtrace/core/conductor.py`:

1. Add optional `ui_callback` parameter to `Conductor.__init__()`
2. Replace direct `dashboard.` calls with callback invocations
3. Key methods to patch:
   - `_update_phase()` → `ui_callback.on_phase_change()`
   - `_update_agent()` → `ui_callback.on_agent_update()`
   - `_report_finding()` → `ui_callback.on_finding()`

```python
class Conductor:
    def __init__(self, target: str, config: Config, ui_callback=None):
        self.ui_callback = ui_callback
        # ... existing init ...

    def _update_phase(self, phase: str, progress: float, status: str):
        if self.ui_callback:
            self.ui_callback.on_phase_change(phase, progress, status)
        # Fallback to legacy dashboard if needed
```

**Important:** Keep backward compatibility with legacy `ui.py` Dashboard.
</task>

<task id="4" name="Add @work scan method to App" depends_on="3">
Update `bugtrace/core/ui/tui/app.py`:

```python
from textual import work
from .workers import UICallback

class BugTraceApp(App):
    def __init__(self, target: str = None, **kwargs):
        super().__init__(**kwargs)
        self.target = target
        self.scan_worker = None

    @work(thread=True, exclusive=True)
    async def run_scan(self, target: str):
        """Execute scan in background thread."""
        from bugtrace.core.conductor import Conductor
        from bugtrace.core.config import Config

        callback = UICallback(self)
        config = Config()
        conductor = Conductor(target, config, ui_callback=callback)

        try:
            await conductor.run()
        except Exception as e:
            callback.on_log("ERROR", str(e))
        finally:
            # Ensure completion message
            pass

    def action_start_scan(self):
        if self.target:
            self.run_scan(self.target)
```

**Note:** Use `thread=True` because the pipeline has blocking I/O.
</task>

<task id="5" name="Implement message handlers in App" depends_on="4">
Add message handlers to `app.py`:

```python
from .messages import *

class BugTraceApp(App):
    # ... existing code ...

    def on_agent_update(self, message: AgentUpdate):
        swarm = self.query_one("#swarm", AgentSwarm)
        swarm.update_agent(message.agent_name, message.status,
                          queue=message.queue, processed=message.processed,
                          vulns=message.vulns)

    def on_pipeline_progress(self, message: PipelineProgress):
        pipeline = self.query_one("#pipeline", PipelineStatus)
        pipeline.phase = message.phase
        pipeline.progress = message.progress
        pipeline.status_msg = message.status_msg

    def on_new_finding(self, message: NewFinding):
        findings = self.query_one("#findings", FindingsSummary)
        findings.add_finding(message)
        self.notify(f"[{message.severity}] {message.finding_type}")

    def on_payload_tested(self, message: PayloadTested):
        feed = self.query_one("#payload-feed", PayloadFeed)
        feed.add_payload(message)

    def on_log_entry(self, message: LogEntry):
        logs = self.query_one("#logs", LogPanel)
        logs.add_log(message.level, message.message)

    def on_metrics_update(self, message: MetricsUpdate):
        metrics = self.query_one("#metrics", SystemMetrics)
        metrics.cpu_usage = message.cpu
        metrics.ram_usage = message.ram
        activity = self.query_one("#activity", ActivityGraph)
        activity.req_rate = message.req_rate

    def on_scan_complete(self, message: ScanComplete):
        self.notify(f"Scan complete: {message.total_findings} findings in {message.duration:.1f}s")
```
</task>

<task id="6" name="Create TUI logging handler" depends_on="5">
Create logging integration:

```python
# In workers.py or separate file
import logging

class TUILoggingHandler(logging.Handler):
    """Routes Python logging to TUI LogPanel."""

    def __init__(self, app):
        super().__init__()
        self.app = app

    def emit(self, record):
        try:
            msg = self.format(record)
            self.app.post_message(LogEntry(record.levelname, msg))
        except Exception:
            self.handleError(record)
```

Install this handler when TUI starts, remove when it stops.
</task>

<task id="7" name="Update CLI to pass target" depends_on="6">
Update `bugtrace/cli/main.py`:

```python
def main():
    args = parse_args()

    if args.tui:
        from bugtrace.core.ui.tui import BugTraceApp
        app = BugTraceApp(target=args.target)
        app.run()
        # Auto-start scan if target provided
    else:
        # Legacy flow
        pass
```
</task>

<task id="8" name="Implement graceful shutdown" depends_on="7">
Handle CTRL+C and clean worker termination:

```python
class BugTraceApp(App):
    async def on_unmount(self):
        """Clean up on app exit."""
        # Cancel any running scan worker
        if self.scan_worker and self.scan_worker.state == WorkerState.RUNNING:
            self.scan_worker.cancel()

        # Restore terminal
        pass

    def action_quit(self):
        """Handle quit with confirmation if scan running."""
        if self.scan_worker and self.scan_worker.state == WorkerState.RUNNING:
            # Could show confirmation dialog
            self.scan_worker.cancel()
        self.exit()
```
</task>

## Verification Criteria

- [ ] `messages.py` defines all 7 message types
- [ ] `workers.py` has UICallback class
- [ ] Conductor accepts `ui_callback` parameter
- [ ] `@work` decorator runs scan in background
- [ ] Message handlers update widgets correctly
- [ ] Logging integrates with TUI
- [ ] CTRL+C stops scan and exits cleanly
- [ ] No "coroutine was never awaited" warnings

## Must-Haves (Goal-Backward)

For Phase 3 (Interactions):
1. **Notification system** - `self.notify()` works for finding alerts
2. **Widget queries** - All widgets accessible via `query_one("#id")`
3. **Worker state** - Can check if scan is running for UI state
4. **Clean cancellation** - Worker can be cancelled mid-scan
