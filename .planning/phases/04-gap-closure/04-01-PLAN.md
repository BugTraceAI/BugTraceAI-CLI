---
phase: 04-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bugtrace/core/team.py
autonomous: true

must_haves:
  truths:
    - "Real scan findings appear in FindingsTable during scans"
    - "Findings show correct type, severity, param, and payload"
    - "TUI remains responsive while receiving findings"
    - "Legacy dashboard unaffected when TUI not active"
  artifacts:
    - path: "bugtrace/core/team.py"
      provides: "EventBus subscription for VULNERABILITY_DETECTED"
      contains: "_on_vulnerability_detected"
  key_links:
    - from: "bugtrace/agents/base.py"
      to: "bugtrace/core/team.py"
      via: "EventBus VULNERABILITY_DETECTED event"
      pattern: "emit.*VULNERABILITY_DETECTED"
    - from: "bugtrace/core/team.py"
      to: "bugtrace/core/conductor.py"
      via: "conductor.notify_finding()"
      pattern: "conductor\\.notify_finding"
    - from: "bugtrace/core/conductor.py"
      to: "bugtrace/core/ui/tui/workers.py"
      via: "ui_callback.on_finding()"
      pattern: "ui_callback\\.on_finding"
---

<objective>
Wire EventBus VULNERABILITY_DETECTED events to TUI FindingsTable

Purpose: Close the critical gap where real scan findings are not displayed in the TUI. Currently, specialists emit findings via EventBus but nothing bridges them to the UI callback system.

Output: FindingsTable displays real-time vulnerability discoveries during active scans.
</objective>

<execution_context>
@/home/albert/.claude/get-shit-done/workflows/execute-plan.md
@/home/albert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-gap-closure/04-CONTEXT.md

# Key source files
@bugtrace/core/team.py
@bugtrace/core/conductor.py
@bugtrace/core/event_bus.py
@bugtrace/agents/base.py
@bugtrace/core/ui/tui/workers.py
@bugtrace/core/ui/tui/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EventBus-to-Conductor Bridge in TeamOrchestrator</name>
  <files>bugtrace/core/team.py</files>
  <action>
Add an async method `_on_vulnerability_detected` to TeamOrchestrator that receives EventBus findings and calls `conductor.notify_finding()`:

```python
async def _on_vulnerability_detected(self, finding: dict) -> None:
    """Bridge EventBus findings to TUI via conductor.

    This method is subscribed to VULNERABILITY_DETECTED events and
    forwards findings to conductor.notify_finding() which routes
    to the TUI if ui_callback is set.
    """
    from bugtrace.core.conductor import conductor

    # Extract fields with fallbacks for different finding formats
    finding_type = finding.get("type", finding.get("finding_type", "Unknown"))
    details = finding.get("details", finding.get("url", "No details"))
    severity = finding.get("severity", "medium")
    param = finding.get("parameter", finding.get("param"))
    payload = finding.get("payload")

    conductor.notify_finding(
        finding_type=finding_type,
        details=details,
        severity=severity,
        param=param,
        payload=payload,
    )
```

In the `__init__` method, add subscription after `self.event_bus = event_bus`:

```python
# Subscribe to findings for TUI updates
from bugtrace.core.event_bus import EventType
self.event_bus.subscribe(EventType.VULNERABILITY_DETECTED.value, self._on_vulnerability_detected)
logger.info("EventBus -> TUI bridge registered for VULNERABILITY_DETECTED")
```

Important considerations:
- Handler MUST be async (EventBus requires async handlers)
- Use `.value` on EventType enum to get string for subscribe()
- Handle both "type" and "finding_type" keys (different specialists use different formats)
- Handle both "parameter" and "param" keys for same reason
- The conductor import is inside the method to avoid circular imports
- No need to unsubscribe - TeamOrchestrator lifecycle matches scan lifecycle
  </action>
  <verify>
1. Run `grep -n "_on_vulnerability_detected" bugtrace/core/team.py` - should show method definition and subscription
2. Run `grep -n "VULNERABILITY_DETECTED" bugtrace/core/team.py` - should show subscription line
3. Run `python -c "from bugtrace.core.team import TeamOrchestrator; print('Import OK')"` - no import errors
  </verify>
  <done>
- TeamOrchestrator has `_on_vulnerability_detected` async method
- Method is subscribed to EventBus VULNERABILITY_DETECTED events
- Method calls conductor.notify_finding() with extracted fields
- No circular import issues
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration Test - Verify End-to-End Flow</name>
  <files>tests/unit/test_eventbus_tui_bridge.py</files>
  <action>
Create a focused unit test that verifies the EventBus to TUI bridge works:

```python
"""Test EventBus to TUI bridge in TeamOrchestrator."""
import asyncio
import pytest
from unittest.mock import Mock, patch, AsyncMock

from bugtrace.core.event_bus import event_bus, EventType


class TestEventBusTUIBridge:
    """Tests for VULNERABILITY_DETECTED -> TUI flow."""

    @pytest.fixture
    def mock_conductor(self):
        """Mock conductor with notify_finding."""
        with patch("bugtrace.core.team.conductor") as mock:
            mock.notify_finding = Mock()
            yield mock

    @pytest.fixture
    def orchestrator(self, mock_conductor, tmp_path):
        """Create TeamOrchestrator with mocked dependencies."""
        with patch("bugtrace.core.team.settings") as mock_settings:
            mock_settings.REPORT_DIR = tmp_path
            from bugtrace.core.team import TeamOrchestrator
            orch = TeamOrchestrator(
                target="https://example.com",
                resume=False,
                use_vertical_agents=False,
            )
            yield orch

    @pytest.mark.asyncio
    async def test_finding_bridges_to_conductor(self, orchestrator, mock_conductor):
        """Verify VULNERABILITY_DETECTED events call conductor.notify_finding."""
        # Emit a finding via EventBus
        finding = {
            "type": "XSS",
            "details": "Reflected XSS in search param",
            "severity": "high",
            "parameter": "q",
            "payload": "<script>alert(1)</script>",
            "url": "https://example.com/search?q=test",
        }

        await event_bus.emit(EventType.VULNERABILITY_DETECTED, finding)

        # Allow async handlers to process
        await asyncio.sleep(0.1)

        # Verify conductor.notify_finding was called
        mock_conductor.notify_finding.assert_called_once()
        call_kwargs = mock_conductor.notify_finding.call_args

        # Check extracted fields
        assert call_kwargs[1]["finding_type"] == "XSS"
        assert call_kwargs[1]["severity"] == "high"
        assert call_kwargs[1]["param"] == "q"
        assert call_kwargs[1]["payload"] == "<script>alert(1)</script>"

    @pytest.mark.asyncio
    async def test_finding_with_alternate_keys(self, orchestrator, mock_conductor):
        """Verify handler works with alternate key names."""
        # Some specialists use "finding_type" instead of "type"
        finding = {
            "finding_type": "SQLi",
            "url": "https://example.com/api",
            "severity": "critical",
            "param": "id",  # Some use "param" instead of "parameter"
        }

        await event_bus.emit(EventType.VULNERABILITY_DETECTED, finding)
        await asyncio.sleep(0.1)

        mock_conductor.notify_finding.assert_called_once()
        call_kwargs = mock_conductor.notify_finding.call_args

        assert call_kwargs[1]["finding_type"] == "SQLi"
        assert call_kwargs[1]["details"] == "https://example.com/api"  # Falls back to url
```

Run the test to verify the bridge works correctly.
  </action>
  <verify>
1. Run `pytest tests/unit/test_eventbus_tui_bridge.py -v` - all tests pass
2. If tests fail, debug and fix the bridge implementation
  </verify>
  <done>
- Test file exists at tests/unit/test_eventbus_tui_bridge.py
- Tests verify finding emission triggers conductor.notify_finding()
- Tests verify both standard and alternate key names work
- All tests pass
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. **Static verification:**
   ```bash
   grep -n "_on_vulnerability_detected" bugtrace/core/team.py
   grep -n "notify_finding" bugtrace/core/team.py
   ```

2. **Unit test verification:**
   ```bash
   pytest tests/unit/test_eventbus_tui_bridge.py -v
   ```

3. **Import verification:**
   ```bash
   python -c "from bugtrace.core.team import TeamOrchestrator; print('OK')"
   ```

4. **Optional manual test (if time permits):**
   ```bash
   # Start TUI with demo mode off against a test target
   bugtraceai tui https://ginandjuice.shop
   # Watch FindingsTable - should show real findings as they're discovered
   ```
</verification>

<success_criteria>
1. TeamOrchestrator subscribes to VULNERABILITY_DETECTED on init
2. Findings emitted by specialists trigger conductor.notify_finding()
3. Unit tests pass verifying the bridge
4. No circular imports or runtime errors
5. TUI displays findings when running real scans (vs staying empty)
</success_criteria>

<output>
After completion, create `.planning/phases/04-gap-closure/04-01-SUMMARY.md`
</output>
