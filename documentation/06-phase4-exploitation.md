# 06 - Fase 4: Exploitation (Agentes Especialistas)

## Resumen

La fase de Exploitation ejecuta **13 agentes especialistas** en paralelo, cada uno experto en un tipo de vulnerabilidad. Reciben trabajo de ThinkingConsolidation (Fase 3) via colas de eventos. Concurrencia: **10** workers (configurable).

**Directorio:** `bugtrace/agents/`

---

## Arquitectura Comun: BaseAgent

Todos los especialistas heredan de `BaseAgent` (`agents/base.py`):

```python
class BaseAgent(ABC):
    def __init__(self, name: str, role: str, event_bus=None, agent_id: str = None):
        self.name = name
        self.role = role
        self.agent_id = agent_id or name.lower().replace("-", "_")
        self.running = False
        self.pause_event = asyncio.Event()
        self.event_bus = event_bus or default_bus

        # System prompt from external Markdown file
        self._load_system_prompt()
        self._setup_event_subscriptions()
```

### Metodos Heredados

| Metodo | Descripcion |
|--------|-------------|
| `start()` | Inicia el loop principal del agente |
| `stop()` | Para el agente y limpia subscripciones |
| `run_loop()` | **Abstracto** - Loop principal (override obligatorio) |
| `think(thought)` | Log de razonamiento interno |
| `check_pause()` | Bloquea si el agente esta pausado |
| `exec_tool(name, func, timeout)` | Ejecuta herramienta con safeguard |
| `_validate_before_emit(finding)` | Valida finding antes de emitirlo |
| `_is_conversational_payload(payload)` | Detecta payloads conversacionales (LLM artifacts) |

### Sistema de Prompts Externos

Cada agente carga su system prompt desde `agents/system_prompts/{agent_id}.md`:

```markdown
---
name: XSS Agent
skills: [xss_payloads, waf_bypass, dom_analysis]
---
# System Prompt

You are a specialized XSS detection agent...
```

El frontmatter YAML define skills a inyectar. El contenido Markdown es el system prompt.

### Inyeccion de Skills

Skills son modulos de conocimiento en `agents/skills/*.md`:
- Se inyectan en el system prompt del agente
- Proporcionan conocimiento especializado (payloads, scoring, FP patterns)
- Cargados automaticamente segun la config del frontmatter

---

## Patron Comun: exploit_dry_list + run_loop

Todos los especialistas implementan dos metodos clave:

```python
async def exploit_dry_list(self) -> List[Dict]:
    """
    Generate list of payloads/tests to execute.
    Called BEFORE the main loop to plan the attack.
    Returns list of test cases.
    """

async def run_loop(self) -> Dict:
    """
    Main execution loop.
    1. Generate dry list (plan)
    2. Execute tests from dry list
    3. Collect and validate results
    4. Return findings dict
    """
```

---

## 1. XSSAgent (`agents/xss_agent.py`)

**El mas grande del sistema: ~358KB, ~7,800 lineas**

### Arquitectura

```
XSSAgent
  |
  +-- Smart Probe (L05)      → Probe HTTP rapido
  +-- Polyglot (L1)          → Payloads polyglot
  +-- Static Bombing (L2)    → Batches de payloads estaticos
  +-- LLM Bombing (L3)       → Payloads generados por LLM
  +-- HTTP Manipulator (L4)  → Manipulacion de headers/encoding
  +-- Browser (L5)           → Validacion Playwright
  +-- CDP (L6)               → Validacion Chrome DevTools
```

### Sistema de Escalacion (6 Niveles)

| Nivel | Nombre | Descripcion | Herramienta |
|-------|--------|-------------|-------------|
| L0.5 | Smart Probe | Probe HTTP rapido para detectar reflexion | aiohttp |
| L1 | Polyglot | Payloads universales | aiohttp |
| L2 | Static Bombing | Batches grandes de payloads conocidos | aiohttp |
| L3 | LLM Bombing | Payloads contextualizados por LLM | aiohttp + LLM |
| L4 | HTTP Manipulator | Encoding tricks, header injection | aiohttp |
| L5 | Browser | Ejecucion real en browser | Playwright |
| L6 | CDP | Validacion final via Chrome DevTools | CDP |

### Metodos Clave

```python
# Discovery
def _check_contexts(html, probe, escaped_probe) -> list
def _detect_surviving_chars(html, prefix) -> str
def _detect_execution_context(payload, html) -> str
def _detect_js_string_delimiter(block, pos) -> str
def _check_reflection(payload, html, evidence) -> bool

# WAF Detection
async def _detect_waf_async() -> Tuple[str, float]
def _detect_payload_encoding(payload) -> str

# Testing
async def _test_single_param_from_queue(param_data) -> Optional[Dict]
async def _test_payload_http_only(url, payload) -> bool
async def _test_with_manipulator(url, payload) -> bool
async def _test_payload_from_queue(test_case) -> Dict
async def _test_smart_llm_payloads(param, context) -> List[Dict]
async def _test_hybrid_payloads(param, context) -> List[Dict]
async def _test_payload_list(param, payloads) -> List[Dict]
async def _test_parameter(param) -> List[Dict]
async def _test_fragment_xss(url, params) -> List[Dict]
async def _test_post_params(url, params) -> List[Dict]

# Validation
async def _check_interactsh_hit(param, evidence) -> bool
```

### Playwright Multi-Context

XSSAgent usa Playwright con multiples contextos de browser para testing paralelo:

```python
# Cada worker tiene su propio browser context
async with browser.new_context() as context:
    page = await context.new_page()
    await page.goto(url_with_payload)
    # Check for XSS execution via page.evaluate()
```

**Workers por defecto:** 8 (mas que otros agentes por ser CPU-intensivo)

---

## 2. SQLiAgent (`agents/sqli_agent.py`)

**~155KB, ~3,400 lineas**

### Tecnicas de Deteccion

| Tecnica | Metodo | Descripcion |
|---------|--------|-------------|
| Error-Based | `_test_error_based()` | Detecta errores SQL en respuesta |
| Boolean-Based | `_test_boolean_based()` | Diferencias en respuesta true/false |
| Time-Based | `_test_time_based()` | Delays medibles (SLEEP) |
| Union-Based | `_test_union_based()` | Inyeccion UNION SELECT |
| OOB (Out-of-Band) | `_test_oob_sqli()` | DNS/HTTP callbacks |
| JSON Body | `_test_json_body_injection()` | Inyeccion en body JSON |
| Second-Order | `_test_second_order_sqli()` | SQLi almacenado |
| Cookie SQLi | `_test_cookie_sqli_from_queue()` | Inyeccion via cookies |

### Integracion con SQLMap

```python
async def _run_sqlmap(self, url: str, param: str) -> Dict:
    """
    Launch SQLMap for authoritative confirmation.
    SQLMap bypasses FP filter - if SQLMap says SQLi, it's SQLi.
    """
    cmd = [
        "sqlmap",
        "-u", url,
        "-p", param,
        "--batch",          # Non-interactive
        "--level", str(level),
        "--risk", str(risk),
        "--output-dir", output_dir,
        "--forms",          # Test forms
        "--dbs",            # Enumerate databases
    ]
```

### Deteccion de DBMS

```python
def _detect_database_type(self, response_text: str) -> Optional[str]:
    """Detect database type from error messages."""
    patterns = {
        "mysql": ["mysql", "mariadb", "SQL syntax.*MySQL"],
        "postgresql": ["postgresql", "pg_", "PSQLException"],
        "mssql": ["Microsoft SQL Server", "ODBC SQL Server"],
        "oracle": ["ORA-", "Oracle"],
        "sqlite": ["SQLite", "sqlite3"],
    }
```

### Deteccion de Prepared Statements

```python
async def _detect_prepared_statements(self, session, param) -> bool:
    """Detect if target uses prepared statements (immune to SQLi)."""
    # Send known-bad payloads, check if they're sanitized
```

---

## 3. CSTIAgent (`agents/csti_agent.py`)

**~142KB**

### Deteccion de Framework

Detecta el framework de templates del target:
- **AngularJS**: `{{7*7}}` → `49`
- **Vue.js**: `{{constructor.constructor('return 1')()}}`
- **React**: JSX injection patterns
- **Jinja2**: `{{config}}`
- **Twig**: `{{_self.env.registerUndefinedFilterCallback('exec')}}`

### Metodos Clave

```python
async def _discover_csti_params(url) -> Dict[str, str]
def _discover_all_params() -> List[Dict]
async def run_loop() -> Dict
async def exploit_dry_list() -> List[Dict]
```

---

## 4-13. Otros Especialistas

### LFIAgent (`agents/lfi_agent.py`, ~46KB)
- Path traversal: `../../etc/passwd`
- Null byte injection: `%00`
- Double encoding: `%252e%252e`
- PHP wrappers: `php://filter/convert.base64-encode`

### IDORAgent (`agents/idor_agent.py`, ~79KB)
- Manipulacion de IDs en URLs y parametros
- Deteccion de acceso horizontal (mismo rol, otro usuario)
- Deteccion de acceso vertical (escalacion de privilegios)

### SSRFAgent (`agents/ssrf_agent.py`, ~40KB)
- Payloads internos: `http://127.0.0.1`, `http://169.254.169.254`
- DNS rebinding
- Protocol smuggling: `gopher://`, `file://`
- Cloud metadata endpoints (AWS, GCP, Azure)

### XXEAgent (`agents/xxe_agent.py`, ~47KB)
- XML External Entity injection
- Blind XXE con OOB callbacks
- XXE via file upload (SVG, DOCX)
- Parameter entity injection

### RCEAgent (`agents/rce_agent.py`, ~36KB)
- Command injection: `; id`, `| whoami`, `` `id` ``
- Code injection (eval, exec)
- SSTI to RCE chains
- Deserialization attacks

### JWTAgent (`agents/jwt_agent.py`, ~60KB)
- Algorithm confusion (none, HS256 vs RS256)
- Key brute force
- JWT claim manipulation
- Token expiration bypass

### OpenRedirectAgent (`agents/openredirect_agent.py`, ~71KB)
- URL parameter manipulation
- JavaScript protocol: `javascript:alert(1)`
- Data URI: `data:text/html,...`
- Double URL encoding

### PrototypePollutionAgent (`agents/prototype_pollution_agent.py`, ~67KB)
- `__proto__` injection
- `constructor.prototype` manipulation
- JSON merge pollution
- Server-side prototype pollution

### HeaderInjectionAgent (`agents/header_injection_agent.py`, ~50KB)
- CRLF injection: `\r\n`
- Host header injection
- X-Forwarded-For manipulation
- Response splitting

### FileUploadAgent (`agents/fileupload_agent.py`, ~17KB)
- Extension bypass (.php.jpg, .phtml)
- Content-Type manipulation
- Magic bytes injection
- Path traversal in filename

---

## Comunicacion con el Pipeline

### Recepcion de Trabajo

Cada especialista se subscribe a su cola:

```python
def _setup_event_subscriptions(self):
    self.event_bus.subscribe(
        f"work_queued_{self.specialist_type}",
        self.handle_work_item
    )
```

### Emision de Resultados

```python
async def _emit_finding(self, finding: Dict):
    # Validate before emitting
    is_valid, error = self._validate_before_emit(finding)
    if not is_valid:
        logger.warning(f"Finding rejected: {error}")
        return

    await self.event_bus.emit("finding_confirmed", {
        "finding": finding,
        "scan_id": self.scan_id,
        "specialist": self.name,
    })
```

### Guardado en Disco

Cada especialista guarda sus resultados en:
```
reports/{target}_{timestamp}/specialists/results/{type}_results.json
```

---

## Worker Pool (`core/worker_pool.py`)

Motor de ejecucion paralela para especialistas:

```python
class WorkerPool:
    def __init__(self, specialist_type: str, max_workers: int = 5):
        self.specialist_type = specialist_type
        self.max_workers = max_workers
        self.queue = asyncio.Queue()
        self.workers = []
```

### Workers por Especialista

| Especialista | Workers Default | Razon |
|--------------|----------------|-------|
| XSSAgent | 8 | CPU-intensivo (Playwright) |
| SQLiAgent | 5 | I/O bound (SQLMap externo) |
| Otros | 5 | Balance general |

### Backpressure

```python
async def _worker_loop(self):
    while self.running:
        item = await self.queue.get()
        try:
            await self._process_item(item)
        finally:
            self.queue.task_done()
```

Rate limiting configurable por especialista para prevenir saturacion del target.

---

## Semaforo de Fase

```python
ScanPhase.EXPLOITATION → Semaphore(10)  # 10 especialistas en paralelo
```

Configurable hasta 30 via `MAX_CONCURRENT_SPECIALISTS`.
